export default [
    { "name": "vm.brk", "doc": "## Name\nprobe::vm.brk — \n     Fires when a brk is requested (i.e. the heap will be resized)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe requested address\n    \n     name of the probe point\n    \n     the length of the memory segment\n\n\n\n## Context\nThe process calling brk.\n\n\n\n" },
    { "name": "vm.kfree", "doc": "## Name\nprobe::vm.kfree — \n     Fires when kfree is requested\n\n\n\n## Synopsis\n\n\n\n\n## Values\naddress of the function calling this kmemory function\n    \n     pointer to the kmemory allocated which is returned by kmalloc\n    \n     name of the probe point\n    \n     name of the caller function.\n\n\n\n" },
    { "name": "vm.kmalloc", "doc": "## Name\nprobe::vm.kmalloc — \n     Fires when kmalloc is requested\n\n\n\n## Synopsis\n\n\n\n\n## Values\nallocated Bytes\n    \n     name of the probe point\n    \n     name of the caller function\n    \n     address of the kmemory function\n    \n     type of kmemory to allocate (in String format)\n    \n     requested Bytes\n    \n     pointer to the kmemory allocated\n    \n     type of kmemory to allocate\n\n\n\n" },
    { "name": "vm.kmalloc_node", "doc": "## Name\nprobe::vm.kmalloc_node — \n     Fires when kmalloc_node is requested\n\n\n\n## Synopsis\n\n\n\n\n## Values\nrequested Bytes\n    \n     type of kmemory to allocate(in string format)\n    \n     address of the function caling this  kmemory function\n    \n     type of kmemory to allocate\n    \n     pointer to the kmemory allocated\n    \n     allocated Bytes\n    \n     name of the caller function\n    \n     name of the probe point\n\n\n\n" },
    { "name": "vm.kmem_cache_alloc", "doc": "## Name\nprobe::vm.kmem_cache_alloc — \n     Fires when kmem_cache_alloc is requested\n\n\n\n## Synopsis\n\n\n\n\n## Values\nrequested Bytes\n    \n     type of kmemory to allocate(in string format)\n    \n     address of the function calling this kmemory function.\n    \n     type of kmemory to allocate\n    \n     pointer to the kmemory allocated\n    \n     allocated Bytes\n    \n     name of the caller function.\n    \n     name of the probe point\n\n\n\n" },
    { "name": "vm.kmem_cache_alloc_node", "doc": "## Name\nprobe::vm.kmem_cache_alloc_node — \n     Fires when kmem_cache_alloc_node is requested\n\n\n\n## Synopsis\n\n\n\n\n## Values\nallocated Bytes\n    \n     name of the caller function\n    \n     name of the probe point\n    \n     type of kmemory to allocate(in string format)\n    \n     requested Bytes\n    \n     address of the function calling this kmemory function\n    \n     pointer to the kmemory allocated\n    \n     type of kmemory to allocate\n\n\n\n" },
    { "name": "vm.kmem_cache_free", "doc": "## Name\nprobe::vm.kmem_cache_free — \n     Fires when kmem_cache_free is requested\n\n\n\n## Synopsis\n\n\n\n\n## Values\nPointer to the kmemory allocated which is returned by kmem_cache\n    \n     Address of the function calling this kmemory function\n    \n     Name of the probe point\n    \n     Name of the caller function.\n\n\n\n" },
    { "name": "vm.mmap", "doc": "## Name\nprobe::vm.mmap — \n     Fires when an mmap is requested\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe length of the memory segment \n    \n     name of the probe point\n    \n     the requested address\n\n\n\n## Context\nThe process calling mmap.\n\n\n\n" },
    { "name": "vm.munmap", "doc": "## Name\nprobe::vm.munmap — \n     Fires when an munmap is requested\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe requested address\n    \n     name of the probe point\n    \n     the length of the memory segment\n\n\n\n## Context\nThe process calling munmap.\n\n\n\n" },
    { "name": "vm.oom_kill", "doc": "## Name\nprobe::vm.oom_kill — \n     Fires when a thread is selected for termination by the OOM killer\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the probe point\n    \n     the task being killed\n\n\n\n## Context\nThe process that tried to consume excessive memory, and thus\n   triggered the OOM.\n\n\n\n" },
    { "name": "vm.pagefault", "doc": "## Name\nprobe::vm.pagefault — \n     Records that a page fault occurred\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe address of the faulting memory access; i.e. the address that caused the page fault\n    \n     name of the probe point\n    \n     indicates whether this was a write or read access; 1 indicates a write, \n     while 0 indicates a read\n\n\n\n## Context\nThe process which triggered the fault\n\n\n\n" },
    { "name": "vm.write_shared", "doc": "## Name\nprobe::vm.write_shared — \n     Attempts at writing to a shared page\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe address of the shared write\n    \n     name of the probe point\n\n\n\n## Context\nThe context is the process attempting the write.\n\n\n\n## Description\nFires when a process attempts to write to a shared page. \n   If a copy is necessary, this will be followed by a \n   vm.write_shared_copy.\n\n\n\n" },
    { "name": "scheduler.balance", "doc": "## Name\nprobe::scheduler.balance — \n     A cpu attempting to find more work.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the probe point\n\n\n\n## Context\nThe cpu looking for more work.\n\n\n\n" },
    { "name": "scheduler.cpu_off", "doc": "## Name\nprobe::scheduler.cpu_off — \n  Process is about to stop running on a cpu\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe process leaving the cpu (same as current)\n    \n     boolean indicating whether current is the idle process\n    \n     the process replacing current\n    \n     name of the probe point\n\n\n\n## Context\nThe process leaving the cpu.\n\n\n\n" },
    { "name": "scheduler.cpu_on", "doc": "## Name\nprobe::scheduler.cpu_on — \n     Process is beginning execution on a cpu\n\n\n\n## Synopsis\n\n\n\n\n## Values\n- boolean indicating whether current is the idle process\n    \n     name of the probe point\n    \n     the process that was previously running on this cpu\n\n\n\n## Context\nThe resuming process.\n\n\n\n" },
    { "name": "vm.write_shared_copy", "doc": "## Name\nprobe::vm.write_shared_copy — \n     Page copy for shared page write\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe address of the shared write\n    \n     boolean indicating whether it is a zero page\n     (can do a clear instead of a copy)\n    \n     Name of the probe point\n\n\n\n## Context\nThe process attempting the write.\n\n\n\n## Description\nFires when a write to a shared page requires a page copy.  This is\n   always preceded by a vm.write_shared.\n\n\n\n" },
    { "name": "vm.pagefault.return", "doc": "## Name\nprobe::vm.pagefault.return — \n     Indicates what type of fault occurred\n\n\n\n## Synopsis\n\n\n\n\n## Values\nreturns either \n     0 (VM_FAULT_OOM) for out of memory faults, \n     2 (VM_FAULT_MINOR) for minor faults, 3 (VM_FAULT_MAJOR) for \n     major faults, or 1 (VM_FAULT_SIGBUS) if the fault was neither OOM, minor fault, \n     nor major fault.\n    \n     name of the probe point\n\n\n\n" },
    { "name": "scheduler.ctxswitch", "doc": "## Name\nprobe::scheduler.ctxswitch — \n     A context switch is occuring.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe priority of the process to be switched in\n    \n     The name of the process to be switched out\n    \n     the state of the process to be switched out\n    \n     The PID of the process to be switched in\n    \n     The TID of the process to be switched out\n    \n     The priority of the process to be switched out\n    \n     the state of the process to be switched in\n    \n     name of the probe point\n    \n     The name of the process to be switched in\n    \n     The TID of the process to be switched in\t \n    \n     The PID of the process to be switched out\n\n\n\n" },
    { "name": "scheduler.kthread_stop", "doc": "## Name\nprobe::scheduler.kthread_stop — \n     A thread created by kthread_create is being stopped\n\n\n\n## Synopsis\n\n\n\n\n## Values\npriority of the thread\n    \n     PID of the thread being stopped\n\n\n\n" },
    { "name": "scheduler.migrate", "doc": "## Name\nprobe::scheduler.migrate — \n     Task migrating across cpus\n\n\n\n## Synopsis\n\n\n\n\n## Values\npriority of the task being migrated\n    \n     name of the probe point\n    \n     the destination cpu\n    \n     PID of the task being migrated\n    \n     the original cpu\n    \n     the process that is being migrated\n\n\n\n" },
    { "name": "scheduler.process_fork", "doc": "## Name\nprobe::scheduler.process_fork — \n     Process forked\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the probe point\n    \n     PID of the parent process\n    \n     PID of the child process\n\n\n\n" },
    { "name": "scheduler.process_exit", "doc": "## Name\nprobe::scheduler.process_exit — \n     Process exiting\n\n\n\n## Synopsis\n\n\n\n\n## Values\nPID of the process exiting\n    \n     name of the probe point\n    \n     priority of the process exiting\n\n\n\n" },
    { "name": "scheduler.process_free", "doc": "## Name\nprobe::scheduler.process_free — \n     Scheduler freeing a data structure for a process\n\n\n\n## Synopsis\n\n\n\n\n## Values\npriority of the process getting freed\n    \n     name of the probe point\n    \n     PID of the process getting freed\n\n\n\n" },
    { "name": "scheduler.signal_send", "doc": "## Name\nprobe::scheduler.signal_send — \n     Sending a signal\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the probe point\n    \n     pid of the process sending signal\n    \n     signal number\n\n\n\n" },
    { "name": "scheduler.process_wait", "doc": "## Name\nprobe::scheduler.process_wait — \n     Scheduler starting to wait on a process\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the probe point\n    \n     PID of the process scheduler is waiting on\n\n\n\n" },
    { "name": "scheduler.tick", "doc": "## Name\nprobe::scheduler.tick — \n     Schedulers internal tick, a processes timeslice accounting is updated\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the probe point\n    \n     boolean indicating whether current is the idle process\n\n\n\n## Context\nThe process whose accounting will be updated.\n\n\n\n" },
    { "name": "scheduler.wait_task", "doc": "## Name\nprobe::scheduler.wait_task — \n     Waiting on a task to unschedule (become inactive)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nPID of the task the scheduler is waiting on\n    \n     priority of the task\n    \n     name of the probe point\n\n\n\n" },
    { "name": "scheduler.wakeup", "doc": "## Name\nprobe::scheduler.wakeup — \n     Task is woken up\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the probe point\n    \n     tid of the task being woken up\n    \n     cpu of the task being woken up\n    \n     PID of the task being woken up\n    \n     priority of the task being woken up\n    \n     state of the task being woken up\n\n\n\n" },
    { "name": "scheduler.kthread_stop.return", "doc": "## Name\nprobe::scheduler.kthread_stop.return — \n     A kthread is stopped and gets the return value\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the probe point\n    \n     return value after stopping the thread\n\n\n\n" },
    { "name": "ioblock.end", "doc": "## Name\nprobe::ioblock.end — \n     Fires whenever a block I/O transfer is complete.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nnumber of segments after physical and DMA remapping hardware coalescing is performed\n    \n     bio vector count which represents number of array element (page, offset, length) which makes up this I/O request\n    \n     total size in bytes\n    \n     number of segments in this bio after physical address coalescing is performed.\n    \n     binary trace for read/write request\n    \n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid\n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n    \n     0 on success\n    \n     operations and flags\n    \n     i-node number of the mapped file\n    \n     offset into the bio vector array\n    \n     number of bytes transferred\n    \n     beginning sector for the entire bio\n    \n     name of the probe point\n    \n     block device name\n\n\n\n## Context\nThe process signals the transfer is done.\n\n\n\n" },
    { "name": "ioblock.request", "doc": "## Name\nprobe::ioblock.request — \n  Fires whenever making a generic block I/O request.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nnumber of segments in this bio after physical address coalescing is performed\n    \n     binary trace for read/write request\n    \n     operations and flags\n    \n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid \n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n    \n     number of segments after physical and DMA remapping hardware coalescing is performed\n    \n     target block device\n    \n     total size in bytes\n    \n     bio vector count which represents number of array element (page, offset, length) which make up this I/O request\n    \n     beginning sector for the entire bio\n    \n     points to the device object which contains the partition (when bio structure represents a partition)\n    \n     block device name\n    \n     points to the start sector of the partition structure of the device\n    \n     name of the probe point\n    \n     offset into the bio vector array\n    \n     i-node number of the mapped file\n\n\n\n## Context\nThe process makes block I/O request\n\n\n\n" },
    { "name": "ioblock_trace.bounce", "doc": "## Name\nprobe::ioblock_trace.bounce — \n     Fires whenever a buffer bounce is needed for at least one page of a block IO request.\n\n\n\n## Synopsis\n\n\n\n\n## Values\ni-node number of the mapped file\n    \n     offset into the bio vector array\n     phys_segments - number of segments in this bio after physical address coalescing is performed.\n    \n     request queue on which this bio was queued.\n    \n     number of bytes transferred\n    \n     beginning sector for the entire bio\n    \n     device for which a buffer bounce was needed.\n    \n     points to the start sector of the partition structure of the device\n    \n     points to the device object which contains the partition (when bio structure represents a partition)\n    \n     name of the probe point\n    \n     target block device\n    \n     bio vector count which represents number of array element (page, offset, length) which makes up this I/O request\n    \n     total size in bytes\n    \n     binary trace for read/write request\n    \n     operations and flags\n    \n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid\n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n\n\n\n## Context\nThe process creating a block IO request.\n\n\n\n" },
    { "name": "ioblock_trace.end", "doc": "## Name\nprobe::ioblock_trace.end — \n     Fires whenever a block I/O transfer is complete.\n\n\n\n## Synopsis\n\n\n\n\n## Values\noffset into the bio vector array\n     phys_segments - number of segments in this bio after physical address coalescing is performed.\n    \n     i-node number of the mapped file\n    \n     number of bytes transferred\n    \n     request queue on which this bio was queued.\n    \n     beginning sector for the entire bio\n    \n     name of the probe point\n    \n     points to the device object which contains the partition (when bio structure represents a partition)\n    \n     points to the start sector of the partition structure of the device\n    \n     block device name\n    \n     target block device\n    \n     total size in bytes\n    \n     bio vector count which represents number of array element (page, offset, length) which makes up this I/O request\n    \n     binary trace for read/write request\n    \n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid\n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n    \n     operations and flags\n\n\n\n## Context\nThe process signals the transfer is done.\n\n\n\n" },
    { "name": "ioblock_trace.request", "doc": "## Name\nprobe::ioblock_trace.request — \n     Fires just as a generic block I/O request is created for a bio.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nnumber of bytes transferred\n    \n     request queue on which this bio was queued.\n    \n     offset into the bio vector array\n     phys_segments - number of segments in this bio after physical address coalescing is performed.\n    \n     i-node number of the mapped file\n    \n     name of the probe point\n    \n     points to the device object which contains the partition (when bio structure represents a partition)\n    \n     points to the start sector of the partition structure of the device\n    \n     block device name\n    \n     beginning sector for the entire bio\n    \n     total size in bytes\n    \n     bio vector count which represents number of array element (page, offset, length) which make up this I/O request\n    \n     target block device\n    \n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid\n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n    \n     operations and flags\n    \n     binary trace for read/write request\n\n\n\n## Context\nThe process makes block I/O request\n\n\n\n" },
    { "name": "ioscheduler.elv_add_request.kp", "doc": "## Name\nprobe::ioscheduler.elv_add_request.kp — \n     kprobe based probe to indicate that a request was added to the request queue\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     Address of the request\n    \n     The type of I/O elevator currently enabled\n    \n     pointer to request queue\n    \n     Disk minor number of the request\n    \n     Request flags\n    \n     Disk major number of the request\n\n\n\n" },
    { "name": "ioscheduler.elv_add_request.tp", "doc": "## Name\nprobe::ioscheduler.elv_add_request.tp — \n     tracepoint based probe to indicate a request is added to the request queue.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nRequest flags.\n    \n     Disk minor number of request.\n    \n     Disk major no of request.\n    \n     The type of I/O elevator currently enabled.\n    \n     Pointer to request queue.\n    \n     Name of the probe point\n    \n     Address of request.\n\n\n\n" },
    { "name": "scheduler.wakeup_new", "doc": "## Name\nprobe::scheduler.wakeup_new — \n     Newly created task is woken up for the first time\n\n\n\n## Synopsis\n\n\n\n\n## Values\nTID of the new task woken up\n    \n     name of the probe point\n    \n     state of the task woken up\n    \n     priority of the new task\n    \n     PID of the new task woken up\n    \n     cpu of the task woken up\n\n\n\n" },
    { "name": "ioscheduler.elv_next_request", "doc": "## Name\nprobe::ioscheduler.elv_next_request — \n  Fires when a request is retrieved from the request queue\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe type of I/O elevator currently enabled\n    \n     Name of the probe point\n\n\n\n" },
    { "name": "ioscheduler_trace.elv_abort_request", "doc": "## Name\nprobe::ioscheduler_trace.elv_abort_request — \n     Fires when a request is aborted.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nRequest flags.\n    \n     Disk minor number of request.\n    \n     Disk major no of request.\n    \n     The type of I/O elevator currently enabled.\n    \n     Address of request.\n    \n     Name of the probe point\n\n\n\n" },
    { "name": "ioscheduler_trace.elv_completed_request", "doc": "## Name\nprobe::ioscheduler_trace.elv_completed_request — \n     Fires when a request is\n\n\n\n## Synopsis\n\n\n\n\n## Values\nRequest flags.\n    \n     Disk minor number of request.\n    \n     Disk major no of request.\n    \n     The type of I/O elevator currently enabled.\n    \n     Name of the probe point\n    \n     Address of request.\n\n\n\n## Description\ncompleted.\n\n\n\n" },
    { "name": "ioscheduler_trace.plug", "doc": "## Name\nprobe::ioscheduler_trace.plug — \n     Fires when a request queue is plugged;\n\n\n\n## Synopsis\n\n\n\n\n## Values\nrequest queue\n    \n     Name of the probe point\n\n\n\n## Description\nie, requests in the queue cannot be serviced by block driver.\n\n\n\n" },
    { "name": "ioscheduler_trace.elv_requeue_request", "doc": "## Name\nprobe::ioscheduler_trace.elv_requeue_request — \n     Fires when a request is\n\n\n\n## Synopsis\n\n\n\n\n## Values\nDisk major no of request.\n    \n     Disk minor number of request.\n    \n     Request flags.\n    \n     Name of the probe point\n    \n     Address of request.\n    \n     The type of I/O elevator currently enabled.\n\n\n\n## Description\nput back on the queue, when the hadware cannot accept more requests.\n\n\n\n" },
    { "name": "ioscheduler.elv_add_request", "doc": "## Name\nprobe::ioscheduler.elv_add_request — \n     probe to indicate request is added to the request queue.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nAddress of request.\n    \n     The type of I/O elevator currently enabled.\n    \n     Pointer to request queue.\n    \n     Disk minor number of request.\n    \n     Request flags.\n    \n     Disk major no of request.\n\n\n\n" },
    { "name": "ioscheduler_trace.unplug_io", "doc": "## Name\nprobe::ioscheduler_trace.unplug_io — \n     Fires when a request queue is unplugged;\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     request queue\n\n\n\n## Description\nEither, when number of pending requests in the queue exceeds threshold\n   or, upon expiration of timer that was activated when queue was plugged.\n\n\n\n" },
    { "name": "ioscheduler.elv_next_request.return", "doc": "## Name\nprobe::ioscheduler.elv_next_request.return — \n     Fires when a request retrieval issues a return signal\n\n\n\n## Synopsis\n\n\n\n\n## Values\nDisk major number of the request\n    \n     Address of the request\n    \n     Name of the probe point\n    \n     Disk minor number of the request\n    \n     Request flags\n\n\n\n" },
    { "name": "ioscheduler_trace.unplug_timer", "doc": "## Name\nprobe::ioscheduler_trace.unplug_timer — \n     Fires when unplug timer associated\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     request queue\n\n\n\n## Description\nwith a request queue expires.\n\n\n\n" },
    { "name": "scsi.iodispatching", "doc": "## Name\nprobe::scsi.iodispatching — \n     SCSI mid-layer dispatched low-level SCSI command\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe channel number\n    \n     The data_direction specifies whether this command is from/to the device\n     0 (DMA_BIDIRECTIONAL), 1 (DMA_TO_DEVICE),\n     2 (DMA_FROM_DEVICE), 3 (DMA_NONE)\n    \n     The current state of the device\n    \n     The host number\n    \n     The current state of the device, as a string\n    \n     The lun number\n    \n     The current struct request pointer, as a number\n    \n     The scsi device id\n    \n     The request buffer length\n    \n     The request buffer address\n    \n     Data direction, as a string\n\n\n\n" },
    { "name": "scsi.iodone", "doc": "## Name\nprobe::scsi.iodone — \n     SCSI command completed by low level driver and enqueued into the done queue.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe data_direction specifies whether this command is\n     from/to the device.\n    \n     The channel number\n    \n     The current state of the device\n    \n     The current struct request pointer, as a number\n    \n     The lun number\n    \n     The current state of the device, as a string\n    \n     1 if a timer is pending on this request\n    \n     The host number\n    \n     Data direction, as a string\n    \n     The scsi device id\n\n\n\n" },
    { "name": "scsi.ioentry", "doc": "## Name\nprobe::scsi.ioentry — \n  Prepares a SCSI mid-layer request\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe current state of the device, as a string\n    \n     The current struct request pointer, as a number\n    \n     The minor number of the disk (-1 if no information)\n    \n     The major number of the disk (-1 if no information)\n    \n     The current state of the device\n\n\n\n" },
    { "name": "scsi.set_state", "doc": "## Name\nprobe::scsi.set_state — \n     Order SCSI device state change\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe host number\n    \n     The lun number\n    \n     The current state of the device, as a string\n    \n     The scsi device id\n    \n     The channel number\n    \n     The current state of the device\n    \n     The new state of the device, as a string\n    \n     The new state of the device\n\n\n\n" },
    { "name": "tty.init", "doc": "## Name\nprobe::tty.init — \n     Called when a tty is being initalized\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe driver  .dev_name name\n    \n     the module name\n    \n     the driver name\n\n\n\n" },
    { "name": "tty.ioctl", "doc": "## Name\nprobe::tty.ioctl — \n     called when a ioctl is request to the tty\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe ioctl command\n    \n     the ioctl argument\n    \n     the file name\n\n\n\n" },
    { "name": "tty.open", "doc": "## Name\nprobe::tty.open — \n  Called when a tty is opened\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe inode flags\n    \n     the file flags\n    \n     the file name\n    \n     the inode state\n    \n     the file mode\n    \n     the inode number\n\n\n\n" },
    { "name": "tty.read", "doc": "## Name\nprobe::tty.read — \n     called when a tty line will be read\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe driver name\n    \n     the file name lreated to the tty\n    \n     The amount of characters to be read\n    \n     the buffer that will receive the characters\n\n\n\n" },
    { "name": "tty.poll", "doc": "## Name\nprobe::tty.poll — \n     Called when a tty device is being polled\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe tty file name\n    \n     the wait queue key\n\n\n\n" },
    { "name": "tty.register", "doc": "## Name\nprobe::tty.register — \n     Called when a tty device is registred\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe tty index requested\n    \n     the driver  .dev_name name\n    \n     the module name\n    \n     the driver name\n\n\n\n" },
    { "name": "tty.receive", "doc": "## Name\nprobe::tty.receive — \n     called when a tty receives a message\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe tty Index\n    \n     The amount of characters received\n    \n     the tty id\n    \n     the driver name\n    \n     The flag buffer\n    \n     the buffer that was received\n    \n     the name of the module file\n\n\n\n" },
    { "name": "ioscheduler.elv_completed_request", "doc": "## Name\nprobe::ioscheduler.elv_completed_request — \n     Fires when a request is completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     Address of the request\n    \n     The type of I/O elevator currently enabled\n    \n     Request flags\n    \n     Disk minor number of the request\n    \n     Disk major number of the request\n\n\n\n" },
    { "name": "tty.release", "doc": "## Name\nprobe::tty.release — \n     Called when the tty is closed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe file flags\n    \n     the file name\n    \n     the inode state\n    \n     the inode flags\n    \n     the file mode\n    \n     the inode number\n\n\n\n" },
    { "name": "tty.resize", "doc": "## Name\nprobe::tty.resize — \n     Called when a terminal resize happens\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe new xpixel value\n    \n     the old xpixel\n    \n     the new row value\n    \n     the tty name\n    \n     the new col value\n    \n     the old ypixel\n    \n     the old col value\n    \n     the new ypixel value\n    \n     the old row value\n\n\n\n" },
    { "name": "tty.write", "doc": "## Name\nprobe::tty.write — \n     write to the tty line\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe driver name\n    \n     the file name lreated to the tty\n    \n     The amount of characters\n    \n     the buffer that will be written\n\n\n\n" },
    { "name": "irq_handler.entry", "doc": "## Name\nprobe::irq_handler.entry — \n     Execution of interrupt handler starting\n\n\n\n## Synopsis\n\n\n\n\n## Values\nstruct irqaction* for this interrupt num\n    \n     thread pointer for threaded interrupts\n    \n     pointer to next irqaction for shared interrupts\n    \n     Cookie to identify device\n    \n     Flags for IRQ handler\n    \n     symbolic string representation of IRQ flags\n    \n     pointer to the proc/irq/NN/name entry\n    \n     interrupt handler function\n    \n     Flags related to thread\n    \n     interrupt handler function for threaded interrupts\n    \n     name of device\n    \n     irq number\n\n\n\n" },
    { "name": "irq_handler.exit", "doc": "## Name\nprobe::irq_handler.exit — \n     Execution of interrupt handler completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the proc/irq/NN/name entry\n    \n     symbolic string representation of IRQ flags\n    \n     struct irqaction*\n    \n     return value of the handler\n    \n     thread pointer for threaded interrupts\n    \n     Cookie to identify device\n    \n     pointer to next irqaction for shared interrupts\n    \n     flags for IRQ handler\n    \n     name of device\n    \n     interrupt number\n    \n     interrupt handler function that was executed\n    \n     Flags related to thread\n    \n     interrupt handler function for threaded interrupts\n\n\n\n" },
    { "name": "softirq.entry", "doc": "## Name\nprobe::softirq.entry — \n     Execution of handler for a pending softirq starting\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to softirq handler just about to execute\n    \n     softirq_action vector\n    \n     softirq vector number\n    \n     struct softirq_action* for current pending softirq\n\n\n\n" },
    { "name": "ioscheduler_trace.elv_issue_request", "doc": "## Name\nprobe::ioscheduler_trace.elv_issue_request — \n     Fires when a request is\n\n\n\n## Synopsis\n\n\n\n\n## Values\nDisk major no of request.\n    \n     Request flags.\n    \n     Disk minor number of request.\n    \n     The type of I/O elevator currently enabled.\n    \n     Address of request.\n    \n     Name of the probe point\n\n\n\n## Description\nscheduled.\n\n\n\n" },
    { "name": "softirq.exit", "doc": "## Name\nprobe::softirq.exit — \n     Execution of handler for a pending softirq completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nstruct softirq_action* for just executed softirq\n    \n     softirq vector number\n    \n     softirq_action vector\n    \n     pointer to softirq handler that just finished execution\n\n\n\n" },
    { "name": "workqueue.create", "doc": "## Name\nprobe::workqueue.create — \n  Creating a new workqueue\n\n\n\n## Synopsis\n\n\n\n\n## Values\ncpu for which the worker thread is created\n    \n     task_struct of the workqueue thread\n\n\n\n" },
    { "name": "workqueue.destroy", "doc": "## Name\nprobe::workqueue.destroy — \n     Destroying workqueue\n\n\n\n## Synopsis\n\n\n\n\n## Values\ntask_struct of the workqueue thread\n\n\n\n" },
    { "name": "workqueue.execute", "doc": "## Name\nprobe::workqueue.execute — \n     Executing deferred work\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to handler function\n    \n     task_struct of the workqueue thread\n    \n     work_struct* being executed\n\n\n\n" },
    { "name": "workqueue.insert", "doc": "## Name\nprobe::workqueue.insert — \n     Queuing work on a workqueue\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to handler function\n    \n     task_struct of the workqueue thread\n    \n     work_struct* being queued\n\n\n\n" },
    { "name": "scsi.iocompleted", "doc": "## Name\nprobe::scsi.iocompleted — \n     SCSI mid-layer running the completion processing for block device I/O requests\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe scsi device id\n    \n     Data direction, as a string\n    \n     The current state of the device, as a string\n    \n     The host number\n    \n     The lun number\n    \n     The bytes completed\n    \n     The current struct request pointer, as a number\n    \n     The current state of the device\n    \n     The data_direction specifies whether this command is from/to\n     the device\n    \n     The channel number\n\n\n\n" },
    { "name": "netdev.change_mac", "doc": "## Name\nprobe::netdev.change_mac — \n     Called when the netdev_name has the MAC changed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that will have the MAC changed\n    \n     The new MAC address\n    \n     The current MAC address\n    \n     The MAC length\n\n\n\n" },
    { "name": "scsi.ioexecute", "doc": "## Name\nprobe::scsi.ioexecute — \n     Create mid-layer SCSI request and wait for the result\n\n\n\n## Synopsis\n\n\n\n\n## Values\nNumber of times to retry request\n    \n     Request timeout in seconds\n    \n     The data_direction specifies whether this command is\n     from/to the device.\n    \n     The channel number\n    \n     The current state of the device\n    \n     The lun number\n    \n     The current state of the device, as a string\n    \n     The host number\n    \n     The data buffer buffer length\n    \n     The data buffer address\n    \n     The scsi device id\n    \n     Data direction, as a string\n\n\n\n" },
    { "name": "netdev.close", "doc": "## Name\nprobe::netdev.close — \n     Called when the device is closed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that is going to be closed\n\n\n\n" },
    { "name": "netdev.change_rx_flag", "doc": "## Name\nprobe::netdev.change_rx_flag — \n     Called when the device RX flag will be changed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that will be changed\n    \n     The new flags\n\n\n\n" },
    { "name": "netdev.get_stats", "doc": "## Name\nprobe::netdev.get_stats — \n     Called when someone asks the device statistics\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that is going to provide the statistics\n\n\n\n" },
    { "name": "netdev.ioctl", "doc": "## Name\nprobe::netdev.ioctl — \n     Called when the device suffers an IOCTL\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe IOCTL request\n    \n     The IOCTL argument (usually the netdev interface)\n\n\n\n" },
    { "name": "netdev.hard_transmit", "doc": "## Name\nprobe::netdev.hard_transmit — \n     Called when the devices is going to TX (hard)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device scheduled to transmit\n    \n     The protocol used in the transmission\n    \n     The size of the data to be transmitted.\n    \n     The length of the transmit buffer.\n\n\n\n" },
    { "name": "tty.unregister", "doc": "## Name\nprobe::tty.unregister — \n     Called when a tty device is being unregistered\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe tty index requested\n    \n     the module name\n    \n     the driver  .dev_name name\n    \n     the driver name\n\n\n\n" },
    { "name": "netdev.open", "doc": "## Name\nprobe::netdev.open — \n     Called when the device is opened\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that is going to be opened\n\n\n\n" },
    { "name": "netdev.receive", "doc": "## Name\nprobe::netdev.receive — \n  Data received from network device.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol of received packet.\n    \n     The name of the device. e.g: eth0, ath1.\n    \n     The length of the receiving buffer.\n\n\n\n" },
    { "name": "netdev.register", "doc": "## Name\nprobe::netdev.register — \n     Called when the device is registered\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that is going to be registered\n\n\n\n" },
    { "name": "netdev.rx", "doc": "## Name\nprobe::netdev.rx — \n     Called when the device is going to receive a packet\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe packet protocol\n    \n     The device received the packet\n\n\n\n" },
    { "name": "netdev.set_promiscuity", "doc": "## Name\nprobe::netdev.set_promiscuity — \n     Called when the device enters/leaves promiscuity\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that is entering/leaving promiscuity mode\n    \n     If the device is leaving promiscuity mode\n    \n     Count the number of promiscuity openers\n    \n     If the device is entering promiscuity mode\n\n\n\n" },
    { "name": "netdev.transmit", "doc": "## Name\nprobe::netdev.transmit — \n     Network device transmitting buffer\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe protocol of this packet(defined in include/linux/if_ether.h).\n    \n     The name of the device. e.g: eth0, ath1.\n    \n     The size of the data to be transmitted.\n    \n     The length of the transmit buffer.\n\n\n\n" },
    { "name": "netfilter.arp.forward", "doc": "## Name\nprobe::netfilter.arp.forward — \n     - Called for each ARP packet to be forwarded\n\n\n\n## Synopsis\n\n\n\n\n## Values\nConstant used to signify an 'accept' verdict\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Ethernet+IP only (ar_pro==0x800): target IP address\n    \n     Format of hardware address\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Constant used to signify a 'queue' verdict\n    \n     Name of network device packet will be routed to (if known)\n    \n     Address of ARP header\n    \n     Address of ARP packet data region (after the header)\n    \n     Format of protocol address\n    \n     Protocol family -- always “arp”\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Constant used to signify a 'drop' verdict\n    \n     Ethernet+IP only (ar_pro==0x800): target hardware (MAC) address\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     Ethernet+IP only (ar_pro==0x800): source hardware (MAC) address \n    \n     A string representing the packet buffer contents\n    \n     Constant used to signify a 'stop' verdict\n    \n     Length of hardware address\n    \n     The length of the packet buffer contents, in bytes\n    \n     Constant used to signify a 'stolen' verdict\n    \n     Length of protocol address\n    \n     Name of network device packet was received on (if known)\n    \n     ARP opcode (command)\n    \n     Ethernet+IP only (ar_pro==0x800): source IP address\n\n\n\n" },
    { "name": "netdev.unregister", "doc": "## Name\nprobe::netdev.unregister — \n     Called when the device is being unregistered\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that is going to be unregistered\n\n\n\n" },
    { "name": "netfilter.arp.in", "doc": "## Name\nprobe::netfilter.arp.in — \n     - Called for each incoming ARP packet\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA hexadecimal string representing the packet buffer contents\n    \n     Ethernet+IP only (ar_pro==0x800): target hardware (MAC) address\n    \n     Constant used to signify a 'drop' verdict\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Address of ARP header\n    \n     Constant used to signify a 'queue' verdict\n    \n     Name of network device packet will be routed to (if known)\n    \n     Protocol family -- always “arp”\n    \n     Format of protocol address\n    \n     Address of ARP packet data region (after the header)\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Ethernet+IP only (ar_pro==0x800): target IP address\n    \n     Format of hardware address\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Constant used to signify an 'accept' verdict\n    \n     ARP opcode (command)\n    \n     Name of network device packet was received on (if known)\n    \n     Ethernet+IP only (ar_pro==0x800): source IP address\n    \n     Length of protocol address\n    \n     Constant used to signify a 'stolen' verdict\n    \n     The length of the packet buffer contents, in bytes\n    \n     Constant used to signify a 'stop' verdict\n    \n     Length of hardware address\n    \n     A string representing the packet buffer contents\n    \n     Ethernet+IP only (ar_pro==0x800): source hardware (MAC) address\n\n\n\n" },
    { "name": "netfilter.arp.out", "doc": "## Name\nprobe::netfilter.arp.out — \n     - Called for each outgoing ARP packet\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA hexadecimal string representing the packet buffer contents\n    \n     Ethernet+IP only (ar_pro==0x800): target hardware (MAC) address\n    \n     Constant used to signify a 'drop' verdict\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Name of network device packet will be routed to (if known)\n    \n     Constant used to signify a 'queue' verdict\n    \n     Address of ARP header\n    \n     Address of ARP packet data region (after the header)\n    \n     Format of protocol address\n    \n     Protocol family -- always “arp”\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Ethernet+IP only (ar_pro==0x800): target IP address\n    \n     Format of hardware address\n    \n     Constant used to signify an 'accept' verdict\n    \n     Name of network device packet was received on (if known)\n    \n     ARP opcode (command)\n    \n     Ethernet+IP only (ar_pro==0x800): source IP address\n    \n     Length of protocol address\n    \n     Constant used to signify a 'stolen' verdict\n    \n     Constant used to signify a 'stop' verdict\n    \n     Length of hardware address\n    \n     The length of the packet buffer contents, in bytes\n    \n     A string representing the packet buffer contents\n    \n     Ethernet+IP only (ar_pro==0x800): source hardware (MAC) address\n\n\n\n" },
    { "name": "netfilter.bridge.forward", "doc": "## Name\nprobe::netfilter.bridge.forward — \n     Called on an incoming bridging packet destined for some other computer\n\n\n\n## Synopsis\n\n\n\n\n## Values\nBPDU type\n    \n     Bridge MAC address\n    \n     Protocol identifier\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Constant used to signify an 'accept' verdict\n    \n     Address of LLC Protocol Data Unit\n    \n     Port identifier\n    \n     Name of network device packet will be routed to (if known)\n    \n     Constant used to signify a 'queue' verdict\n    \n     Protocol family -- always “bridge”\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Message age in 1/256 secs\n    \n     Constant used to signify a 'drop' verdict\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Address of bridge header\n    \n     Protocol version identifier\n    \n     BPDU flags\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     Forward delay in 1/256 secs\n    \n     Root bridge MAC address\n    \n     Constant used to signify Bridge Spanning Tree Protocol packet\n    \n     Max age in 1/256 secs\n    \n     Identity of root bridge\n    \n     The length of the packet buffer contents, in bytes\n    \n     Constant used to signify a 'stop' verdict\n    \n     Packet protocol\n    \n     A string representing the packet buffer contents\n    \n     Identity of bridge\n    \n     Constant used to signify a 'stolen' verdict\n    \n     Name of network device packet was received on (if known)\n    \n     Hello time in 1/256 secs\n    \n     Total cost from transmitting bridge to root\n\n\n\n" },
    { "name": "netfilter.bridge.local_in", "doc": "## Name\nprobe::netfilter.bridge.local_in — \n     Called on a bridging packet destined for the local computer\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of network device packet was received on (if known)\n    \n     Total cost from transmitting bridge to root\n    \n     Hello time in 1/256 secs\n    \n     Constant used to signify a 'stop' verdict\n    \n     The length of the packet buffer contents, in bytes\n    \n     Packet protocol\n    \n     A string representing the packet buffer contents\n    \n     Constant used to signify a 'stolen' verdict\n    \n     Identity of bridge\n    \n     Constant used to signify a 'drop' verdict\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Address of bridge header\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     BPDU flags\n    \n     Protocol version identifier\n    \n     Root bridge MAC address\n    \n     Forward delay in 1/256 secs\n    \n     Max age in 1/256 secs\n    \n     Identity of root bridge\n    \n     Constant used to signify Bridge Spanning Tree Protocol packet\n    \n     Bridge MAC address\n    \n     BPDU type\n    \n     Protocol identifier\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Constant used to signify an 'accept' verdict\n    \n     Address of LLC Protocol Data Unit\n    \n     Name of network device packet will be routed to (if known)\n    \n     Constant used to signify a 'queue' verdict\n    \n     Port identifier\n    \n     Protocol family -- always “bridge”\n    \n     Message age in 1/256 secs\n    \n     Address of net_device representing input device, 0 if unknown\n\n\n\n" },
    { "name": "netfilter.bridge.post_routing", "doc": "## Name\nprobe::netfilter.bridge.post_routing — \n     - Called before a bridging packet hits the wire\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of network device packet was received on (if known)\n    \n     Hello time in 1/256 secs\n    \n     Total cost from transmitting bridge to root\n    \n     The length of the packet buffer contents, in bytes\n    \n     Constant used to signify a 'stop' verdict\n    \n     Packet protocol\n    \n     A string representing the packet buffer contents\n    \n     Constant used to signify a 'stolen' verdict\n    \n     Identity of bridge\n    \n     Constant used to signify a 'drop' verdict\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Address of bridge header\n    \n     Protocol version identifier\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     BPDU flags\n    \n     Forward delay in 1/256 secs\n    \n     Root bridge MAC address\n    \n     Constant used to signify Bridge Spanning Tree Protocol packet\n    \n     Max age in 1/256 secs\n    \n     Identity of root bridge\n    \n     BPDU type\n    \n     Bridge MAC address\n    \n     Protocol identifier\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Address of LLC Protocol Data Unit\n    \n     Constant used to signify an 'accept' verdict\n    \n     Port identifier\n    \n     Constant used to signify a 'queue' verdict\n    \n     Name of network device packet will be routed to (if known)\n    \n     Protocol family -- always “bridge”\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Message age in 1/256 secs\n\n\n\n" },
    { "name": "netfilter.bridge.local_out", "doc": "## Name\nprobe::netfilter.bridge.local_out — \n     Called on a bridging packet coming from a local process\n\n\n\n## Synopsis\n\n\n\n\n## Values\nIdentity of bridge\n    \n     Constant used to signify a 'stolen' verdict\n    \n     Packet protocol\n    \n     The length of the packet buffer contents, in bytes\n    \n     Constant used to signify a 'stop' verdict\n    \n     A string representing the packet buffer contents\n    \n     Name of network device packet was received on (if known)\n    \n     Hello time in 1/256 secs\n    \n     Total cost from transmitting bridge to root\n    \n     Protocol family -- always “bridge”\n    \n     Port identifier\n    \n     Constant used to signify a 'queue' verdict\n    \n     Name of network device packet will be routed to (if known)\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Message age in 1/256 secs\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Protocol identifier\n    \n     BPDU type\n    \n     Bridge MAC address\n    \n     Address of LLC Protocol Data Unit\n    \n     Constant used to signify an 'accept' verdict\n    \n     Protocol version identifier\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     BPDU flags\n    \n     Address of bridge header\n    \n     Constant used to signify Bridge Spanning Tree Protocol packet\n    \n     Identity of root bridge\n    \n     Max age in 1/256 secs\n    \n     Forward delay in 1/256 secs\n    \n     Root bridge MAC address\n    \n     Constant used to signify a 'drop' verdict\n    \n     Address of net_device representing output device, 0 if unknown\n\n\n\n" },
    { "name": "netfilter.ip.forward", "doc": "## Name\nprobe::netfilter.ip.forward — \n     Called on an incoming IP packet addressed to some other computer\n\n\n\n## Synopsis\n\n\n\n\n## Values\nAddress of net_device representing output device, 0 if unknown\n    \n     IP address family\n    \n     Constant used to signify that the packet protocol is TCP\n    \n     Constant used to signify a 'drop' verdict\n    \n     A string representing the source IP address\n    \n     Address of IP header\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     TCP or UDP destination port (ipv4 only)\n    \n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify an 'accept' verdict\n    \n     Constant used to signify that the packet protocol is UDP\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     TCP ACK flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify a 'queue' verdict\n    \n     Name of network device packet will be routed to (if known)\n    \n     Protocol family -- either “ipv4” or “ipv6”\n    \n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    \n     Name of network device packet was received on (if known)\n    \n     TCP RST flag (if protocol is TCP; ipv4 only)\n    \n     A string representing the packet buffer contents\n    \n     TCP or UDP source port (ipv4 only)\n    \n     Constant used to signify a 'stop' verdict\n    \n     A string representing the destination IP address\n    \n     The length of the packet buffer contents, in bytes\n    \n     Packet protocol from driver (ipv4 only)\n    \n     TCP URG flag (if protocol is TCP; ipv4 only)\n    \n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify a 'stolen' verdict\n\n\n\n" },
    { "name": "netfilter.bridge.pre_routing", "doc": "## Name\nprobe::netfilter.bridge.pre_routing — \n     - Called before a bridging packet is routed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nAddress of net_device representing output device, 0 if unknown\n    \n     Constant used to signify a 'drop' verdict\n    \n     Forward delay in 1/256 secs\n    \n     Root bridge MAC address\n    \n     Constant used to signify Bridge Spanning Tree Protocol packet\n    \n     Max age in 1/256 secs\n    \n     Identity of root bridge\n    \n     Address of bridge header\n    \n     Protocol version identifier\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     BPDU flags\n    \n     Address of LLC Protocol Data Unit\n    \n     Constant used to signify an 'accept' verdict\n    \n     BPDU type\n    \n     Bridge MAC address\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Protocol identifier\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Message age in 1/256 secs\n    \n     Port identifier\n    \n     Name of network device packet will be routed to (if known)\n    \n     Constant used to signify a 'queue' verdict\n    \n     Protocol family -- always “bridge”\n    \n     Hello time in 1/256 secs\n    \n     Total cost from transmitting bridge to root\n    \n     Name of network device packet was received on (if known)\n    \n     A string representing the packet buffer contents\n    \n     The length of the packet buffer contents, in bytes\n    \n     Constant used to signify a 'stop' verdict\n    \n     Packet protocol\n    \n     Identity of bridge\n    \n     Constant used to signify a 'stolen' verdict\n\n\n\n" },
    { "name": "netfilter.ip.local_in", "doc": "## Name\nprobe::netfilter.ip.local_in — \n     Called on an incoming IP packet addressed to the local computer\n\n\n\n## Synopsis\n\n\n\n\n## Values\nAddress of net_device representing output device, 0 if unknown\n    \n     Constant used to signify that the packet protocol is TCP\n    \n     IP address family\n    \n     Constant used to signify a 'drop' verdict\n    \n     A string representing the source IP address\n    \n     Address of IP header\n    \n     TCP or UDP destination port (ipv4 only)\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify an 'accept' verdict\n    \n     Constant used to signify that the packet protocol is UDP\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     TCP ACK flag (if protocol is TCP; ipv4 only)\n    \n     Name of network device packet will be routed to (if known)\n    \n     Constant used to signify a 'queue' verdict\n    \n     Protocol family -- either “ipv4” or “ipv6”\n    \n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    \n     TCP RST flag (if protocol is TCP; ipv4 only)\n    \n     Name of network device packet was received on (if known)\n    \n     TCP or UDP source port (ipv4 only)\n    \n     A string representing the packet buffer contents\n    \n     A string representing the destination IP address\n    \n     The length of the packet buffer contents, in bytes\n    \n     Constant used to signify a 'stop' verdict\n    \n     Packet protocol from driver (ipv4 only)\n    \n     TCP URG flag (if protocol is TCP; ipv4 only)\n    \n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify a 'stolen' verdict\n\n\n\n" },
    { "name": "netfilter.ip.local_out", "doc": "## Name\nprobe::netfilter.ip.local_out — \n     Called on an outgoing IP packet\n\n\n\n## Synopsis\n\n\n\n\n## Values\nTCP RST flag (if protocol is TCP; ipv4 only)\n    \n     Name of network device packet was received on (if known)\n    \n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify a 'stolen' verdict\n    \n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    \n     TCP URG flag (if protocol is TCP; ipv4 only)\n    \n     Packet protocol from driver (ipv4 only)\n    \n     A string representing the destination IP address\n    \n     The length of the packet buffer contents, in bytes\n    \n     Constant used to signify a 'stop' verdict\n    \n     TCP or UDP source port (ipv4 only)\n    \n     A string representing the packet buffer contents\n    \n     TCP or UDP destination port (ipv4 only)\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     Address of IP header\n    \n     A string representing the source IP address\n    \n     Constant used to signify a 'drop' verdict\n    \n     Constant used to signify that the packet protocol is TCP\n    \n     IP address family\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Protocol family -- either “ipv4” or “ipv6”\n    \n     Name of network device packet will be routed to (if known)\n    \n     Constant used to signify a 'queue' verdict\n    \n     TCP ACK flag (if protocol is TCP; ipv4 only)\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Constant used to signify that the packet protocol is UDP\n    \n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify an 'accept' verdict\n\n\n\n" },
    { "name": "netfilter.ip.post_routing", "doc": "## Name\nprobe::netfilter.ip.post_routing — \n     Called immediately before an outgoing IP packet leaves the computer\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of network device packet was received on (if known)\n    \n     TCP RST flag (if protocol is TCP; ipv4 only)\n    \n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify a 'stop' verdict\n    \n     The length of the packet buffer contents, in bytes\n    \n     A string representing the destination IP address\n    \n     Packet protocol from driver (ipv4 only)\n    \n     A string representing the packet buffer contents\n    \n     TCP or UDP source port (ipv4 only)\n    \n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify a 'stolen' verdict\n    \n     TCP URG flag (if protocol is TCP; ipv4 only)\n    \n     IP address family\n    \n     Constant used to signify that the packet protocol is TCP\n    \n     Constant used to signify a 'drop' verdict\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Address of IP header\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     TCP or UDP destination port (ipv4 only)\n    \n     A string representing the source IP address\n    \n     Constant used to signify a 'repeat' verdict\n    \n     Constant used to signify an 'accept' verdict\n    \n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify that the packet protocol is UDP\n    \n     Constant used to signify a 'queue' verdict\n    \n     Name of network device packet will be routed to (if known)\n    \n     Protocol family -- either “ipv4” or “ipv6”\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     TCP ACK flag (if protocol is TCP; ipv4 only)\n\n\n\n" },
    { "name": "netfilter.ip.pre_routing", "doc": "## Name\nprobe::netfilter.ip.pre_routing — \n  Called before an IP packet is routed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nTCP URG flag (if protocol is TCP; ipv4 only)\n    \n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify a 'stolen' verdict\n    \n     A string representing the packet buffer contents\n    \n     TCP or UDP source port (ipv4 only)\n    \n     Packet protocol from driver (ipv4 only)\n    \n     Constant used to signify a 'stop' verdict\n    \n     The length of the packet buffer contents, in bytes\n    \n     A string representing the destination IP address\n    \n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    \n     Name of network device packet was received on (if known)\n    \n     TCP RST flag (if protocol is TCP; ipv4 only)\n    \n     TCP ACK flag (if protocol is TCP; ipv4 only)\n    \n     Address of net_device representing input device, 0 if unknown\n    \n     Protocol family - either 'ipv4' or 'ipv6'\n    \n     Constant used to signify a 'queue' verdict\n    \n     Name of network device packet will be routed to (if known)\n    \n     Constant used to signify that the packet protocol is UDP\n    \n     Constant used to signify an 'accept' verdict\n    \n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    \n     Constant used to signify a 'repeat' verdict\n    \n     A string representing the source IP address\n    \n     A hexadecimal string representing the packet buffer contents\n    \n     TCP or UDP destination port (ipv4 only)\n    \n     Address of IP header\n    \n     Address of net_device representing output device, 0 if unknown\n    \n     Constant used to signify a 'drop' verdict\n    \n     IP address family\n    \n     Constant used to signify that the packet protocol is TCP\n\n\n\n" },
    { "name": "sunrpc.clnt.bind_new_program", "doc": "## Name\nprobe::sunrpc.clnt.bind_new_program — \n     Bind a new RPC program to an existing client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe number of old RPC program\n    \n     the name of old RPC program\n    \n     the version of new RPC program\n    \n     the version of old RPC program\n    \n     the name of new RPC program\n    \n     the number of new RPC program\n    \n     the server machine name\n\n\n\n" },
    { "name": "sunrpc.clnt.call_async", "doc": "## Name\nprobe::sunrpc.clnt.call_async — \n     Make an asynchronous RPC call\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe procedure number in this RPC call\n    \n     the port number\n    \n     the procedure name in this RPC call\n    \n     flags\n    \n     current transmission id\n    \n     the server machine name\n    \n     the RPC program name\n    \n     the IP protocol number\n    \n     whether this client is abandoned\n    \n     the RPC program version number\n    \n     the RPC program number\n\n\n\n" },
    { "name": "sunrpc.clnt.call_sync", "doc": "## Name\nprobe::sunrpc.clnt.call_sync — \n     Make a synchronous RPC call\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe RPC program version number\n    \n     the RPC program name\n    \n     the IP protocol number\n    \n     whether this client is abandoned\n    \n     the RPC program number\n    \n     the port number\n    \n     the procedure number in this RPC call\n    \n     the procedure name in this RPC call\n    \n     flags\n    \n     the server machine name\n    \n     current transmission id\n\n\n\n" },
    { "name": "sunrpc.clnt.clone_client", "doc": "## Name\nprobe::sunrpc.clnt.clone_client — \n     Clone an RPC client structure\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe RPC program version number\n    \n     the authentication flavor\n    \n     the RPC program name\n    \n     the IP protocol number\n    \n     the server machine name\n    \n     the RPC program number\n    \n     the port number\n\n\n\n" },
    { "name": "sunrpc.clnt.restart_call", "doc": "## Name\nprobe::sunrpc.clnt.restart_call — \n     Restart an asynchronous RPC call\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe RPC program number\n    \n     the debugging aid of task\n    \n     the task run status\n    \n     the task flags\n    \n     the task priority\n    \n     the transmission id\n    \n     the server machine name\n\n\n\n" },
    { "name": "sunrpc.clnt.create_client", "doc": "## Name\nprobe::sunrpc.clnt.create_client — \n  Create an RPC client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe port number\n    \n     the server machine name\n    \n     the RPC program number\n    \n     the RPC program version number\n    \n     the IP protocol number\n    \n     the RPC program name\n    \n     the authentication flavor\n\n\n\n" },
    { "name": "sunrpc.clnt.shutdown_client", "doc": "## Name\nprobe::sunrpc.clnt.shutdown_client — \n     Shutdown an RPC client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe number of clones\n    \n     the count of bytes in\n    \n     the server machine name\n    \n     the RPC RTT jiffies\n    \n     the RPC execution jiffies\n    \n     the number of references\n    \n     the jiffies queued for xmit\n    \n     the port number\n    \n     the RPC program number\n    \n     the count of reconnections\n    \n     the count of bytes out\n    \n     the count of operations\n    \n     the RPC program name\n    \n     the authentication flavor\n    \n     the IP protocol number\n    \n     the count of RPC calls\n    \n     the RPC program version number\n    \n     the count of RPC transmissions\n\n\n\n" },
    { "name": "sunrpc.sched.delay", "doc": "## Name\nprobe::sunrpc.sched.delay — \n     Delay an RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe program number in the RPC call\n    \n     the program version in the RPC call\n    \n     the flags of the task\n    \n     the debugging id of the task\n    \n     the IP protocol in the RPC call\n    \n     the transmission id in the RPC call\n    \n     the time delayed\n\n\n\n" },
    { "name": "sunrpc.sched.execute", "doc": "## Name\nprobe::sunrpc.sched.execute — \n     Execute the RPC `scheduler'\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe IP protocol in the RPC call\n    \n     the program version in the RPC call\n    \n     the debugging id of the task\n    \n     the flags of the task\n    \n     the program number in the RPC call\n    \n     the transmission id in the RPC call\n\n\n\n" },
    { "name": "sunrpc.sched.new_task", "doc": "## Name\nprobe::sunrpc.sched.new_task — \n     Create new task for the specified client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe flags of the task\n    \n     the program version in the RPC call\n    \n     the IP protocol in the RPC call\n    \n     the program number in the RPC call\n    \n     the transmission id in the RPC call\n\n\n\n" },
    { "name": "sunrpc.sched.release_task", "doc": "## Name\nprobe::sunrpc.sched.release_task — \n     Release all resources associated with a task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe transmission id in the RPC call\n    \n     the program version in the RPC call\n    \n     the flags of the task\n    \n     the IP protocol in the RPC call\n    \n     the program number in the RPC call\n\n\n\n## Description\nrpc_release_task function might not be found for a particular kernel.\n   So, if we can't find it, just return '-1' for everything.\n\n\n\n" },
    { "name": "sunrpc.svc.create", "doc": "## Name\nprobe::sunrpc.svc.create — \n     Create an RPC service\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe number of supported versions\n    \n     the name of the program\n    \n     the number of the program\n    \n     the buffer size\n\n\n\n" },
    { "name": "sunrpc.svc.destroy", "doc": "## Name\nprobe::sunrpc.svc.destroy — \n     Destroy an RPC service\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe number of the program\n    \n     the count of accepted TCP connections\n    \n     the count of received RPC requests\n    \n     the service name\n    \n     the count of requests dropped for bad formats\n    \n     the count of requests drooped for authentication failure\n    \n     the name of the program\n    \n     the number of concurrent threads\n    \n     the count of valid RPC requests\n\n\n\n" },
    { "name": "sunrpc.svc.drop", "doc": "## Name\nprobe::sunrpc.svc.drop — \n     Drop RPC request\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe program version in the request\n    \n     the IP protocol of the reqeust\n    \n     the program number in the request\n    \n     the transmission id in the request\n    \n     the procedure number in the request\n    \n     the peer address where the request is from\n    \n     the service name\n\n\n\n" },
    { "name": "sunrpc.svc.recv", "doc": "## Name\nprobe::sunrpc.svc.recv — \n     Listen for the next RPC request on any socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe number of concurrent threads\n    \n     the service name\n    \n     the timeout of waiting for data\n    \n     the number of the program\n\n\n\n" },
    { "name": "sunrpc.svc.register", "doc": "## Name\nprobe::sunrpc.svc.register — \n     Register an RPC service with the local portmapper\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe number of the program\n    \n     the IP protocol number\n    \n     the name of the program\n    \n     the service name\n    \n     the port number\n\n\n\n## Description\nIf proto and port are both 0, then unregister a service.\n\n\n\n" },
    { "name": "sunrpc.svc.send", "doc": "## Name\nprobe::sunrpc.svc.send — \n     Return reply to RPC client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe procedure number in the request\n    \n     the transmission id in the request\n    \n     the program number in the request\n    \n     the IP protocol of the reqeust\n    \n     the program version in the request\n    \n     the service name\n    \n     the peer address where the request is from\n\n\n\n" },
    { "name": "tcp.disconnect.return", "doc": "## Name\nprobe::tcp.disconnect.return — \n     TCP socket disconnection complete\n\n\n\n## Synopsis\n\n\n\n\n## Values\nError code (0: no error) \n    \n     Name of this probe\n\n\n\n## Context\nThe process which disconnects tcp\n\n\n\n" },
    { "name": "tcp.receive", "doc": "## Name\nprobe::tcp.receive — \n     Called when a TCP packet is received\n\n\n\n## Synopsis\n\n\n\n\n## Values\nTCP PSH flag\n    \n     TCP URG flag\n    \n     IP header address\n    \n     TCP SYN flag\n    \n     A string representing the destination IP address\n    \n     TCP RST flag\n    \n     TCP source port\n    \n     Name of the probe point\n    \n     TCP ACK flag\n    \n     IP address family\n    \n     A string representing the source IP address\n    \n     TCP FIN flag\n    \n     Packet protocol from driver\n    \n     TCP destination port\n\n\n\n" },
    { "name": "tcp.disconnect", "doc": "## Name\nprobe::tcp.disconnect — \n     TCP socket disconnection\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of this probe\n    \n     IP address family\n    \n     A string representing the source IP address\n    \n     A string representing the destination IP address\n    \n     TCP flags (e.g. FIN, etc)  \n    \n     TCP destination port\n    \n     Network socket \n    \n     TCP source port\n\n\n\n## Context\nThe process which disconnects tcp\n\n\n\n" },
    { "name": "tcp.recvmsg", "doc": "## Name\nprobe::tcp.recvmsg — \n     Receiving TCP message\n\n\n\n## Synopsis\n\n\n\n\n## Values\nTCP destination port\n    \n     Network socket\n    \n     Number of bytes to be received  \n    \n     TCP source port \n    \n     A string representing the source IP address\n    \n     A string representing the destination IP address\n    \n     IP address family\n    \n     Name of this probe\n\n\n\n## Context\nThe process which receives a tcp message\n\n\n\n" },
    { "name": "tcp.recvmsg.return", "doc": "## Name\nprobe::tcp.recvmsg.return — \n     Receiving TCP message complete\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA string representing the source IP address\n    \n     A string representing the destination IP address\n    \n     TCP destination port\n    \n     Number of bytes received or error code if an error occurred.\n    \n     TCP source port \n    \n     Name of this probe\n    \n     IP address family\n\n\n\n## Context\nThe process which receives a tcp message\n\n\n\n" },
    { "name": "sunrpc.svc.process", "doc": "## Name\nprobe::sunrpc.svc.process — \n     Process an RPC request\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe number of concurrent threads\n    \n     the service name\n    \n     the peer address where the request is from\n    \n     the program version in the request\n    \n     the IP protocol of the reqeust\n    \n     the program number in the request\n    \n     the procedure number in the request\n    \n     the number of the program\n    \n     the transmission id in the request\n\n\n\n" },
    { "name": "tcp.sendmsg", "doc": "## Name\nprobe::tcp.sendmsg — \n  Sending a tcp message\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of this probe\n    \n     IP address family\n    \n     Network socket \n    \n     Number of bytes to send\n\n\n\n## Context\nThe process which sends a tcp message\n\n\n\n" },
    { "name": "tcp.sendmsg.return", "doc": "## Name\nprobe::tcp.sendmsg.return — \n     Sending TCP message is done\n\n\n\n## Synopsis\n\n\n\n\n## Values\nNumber of bytes sent or error code if an error occurred. \n    \n     Name of this probe\n\n\n\n## Context\nThe process which sends a tcp message\n\n\n\n" },
    { "name": "tcp.setsockopt", "doc": "## Name\nprobe::tcp.setsockopt — \n     Call to setsockopt\n\n\n\n## Synopsis\n\n\n\n\n## Values\nIP address family\n    \n     The level at which the socket options will be manipulated\n    \n     TCP socket options (e.g. TCP_NODELAY, TCP_MAXSEG, etc)\n    \n     Name of this probe\n    \n     Used to access values for setsockopt\n    \n     Resolves optname to a human-readable format\n    \n     Network socket\n\n\n\n## Context\nThe process which calls setsockopt\n\n\n\n" },
    { "name": "tcp.setsockopt.return", "doc": "## Name\nprobe::tcp.setsockopt.return — \n     Return from setsockopt\n\n\n\n## Synopsis\n\n\n\n\n## Values\nError code (0: no error)\n    \n     Name of this probe\n\n\n\n## Context\nThe process which calls setsockopt\n\n\n\n" },
    { "name": "udp.disconnect", "doc": "## Name\nprobe::udp.disconnect — \n     Fires when a process requests for a UDP disconnection\n\n\n\n## Synopsis\n\n\n\n\n## Values\nIP address family\n    \n     A string representing the source IP address\n    \n     UDP destination port\n    \n     A string representing the destination IP address\n    \n     Flags (e.g. FIN, etc)  \n    \n     UDP source port\n    \n     The name of this probe\n    \n     Network socket used by the process\n\n\n\n## Context\nThe process which requests a UDP disconnection\n\n\n\n" },
    { "name": "udp.disconnect.return", "doc": "## Name\nprobe::udp.disconnect.return — \n     UDP has been disconnected successfully\n\n\n\n## Synopsis\n\n\n\n\n## Values\nUDP source port\n    \n     The name of this probe\n    \n     A string representing the destination IP address\n    \n     UDP destination port\n    \n     IP address family\n    \n     A string representing the source IP address\n    \n     Error code (0: no error)\n\n\n\n## Context\nThe process which requested a UDP disconnection\n\n\n\n" },
    { "name": "udp.recvmsg", "doc": "## Name\nprobe::udp.recvmsg — \n     Fires whenever a UDP message is received\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA string representing the destination IP address\n    \n     UDP source port\n    \n     Network socket used by the process\n    \n     The name of this probe\n    \n     IP address family\n    \n     A string representing the source IP address\n    \n     Number of bytes received by the process\n    \n     UDP destination port\n\n\n\n## Context\nThe process which received a UDP message\n\n\n\n" },
    { "name": "udp.recvmsg.return", "doc": "## Name\nprobe::udp.recvmsg.return — \n     Fires whenever an attempt to receive a UDP message received is completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe name of this probe\n    \n     UDP source port\n    \n     A string representing the destination IP address\n    \n     UDP destination port\n    \n     Number of bytes received by the process\n    \n     A string representing the source IP address\n    \n     IP address family\n\n\n\n## Context\nThe process which received a UDP message\n\n\n\n" },
    { "name": "udp.sendmsg", "doc": "## Name\nprobe::udp.sendmsg — \n  Fires whenever a process sends a UDP message\n\n\n\n## Synopsis\n\n\n\n\n## Values\nNetwork socket used by the process \n    \n     The name of this probe\n    \n     UDP source port\n    \n     A string representing the destination IP address\n    \n     Number of bytes sent by the process\n    \n     UDP destination port\n    \n     A string representing the source IP address\n    \n     IP address family\n\n\n\n## Context\nThe process which sent a UDP message\n\n\n\n" },
    { "name": "udp.sendmsg.return", "doc": "## Name\nprobe::udp.sendmsg.return — \n     Fires whenever an attempt to send a UDP message is completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe name of this probe\n    \n     Number of bytes sent by the process\n\n\n\n## Context\nThe process which sent a UDP message\n\n\n\n" },
    { "name": "netdev.change_mtu", "doc": "## Name\nprobe::netdev.change_mtu — \n     Called when the netdev MTU is changed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe device that will have the MTU changed\n    \n     The new MTU\n    \n     The current MTU\n\n\n\n" },
    { "name": "socket.aio_read", "doc": "## Name\nprobe::socket.aio_read — \n     Receiving message via sock_aio_read\n\n\n\n## Synopsis\n\n\n\n\n## Values\nSocket state value\n    \n     Message size in bytes\n    \n     Socket flags value\n    \n     Protocol family value\n    \n     Protocol value\n    \n     Name of this probe\n    \n     Socket type value\n\n\n\n## Context\nThe message sender\n\n\n\n## Description\nFires at the beginning of receiving a message on a socket\n   via the sock_aio_read function\n\n\n\n" },
    { "name": "socket.aio_read.return", "doc": "## Name\nprobe::socket.aio_read.return — \n     Conclusion of message received via sock_aio_read\n\n\n\n## Synopsis\n\n\n\n\n## Values\nSocket flags value\n    \n     Size of message received (in bytes) or error code if success = 0\n    \n     Socket state value\n    \n     Protocol family value\n    \n     Protocol value\n    \n     Name of this probe\n    \n     Was receive successful? (1 = yes, 0 = no)\n    \n     Socket type value\n\n\n\n## Context\nThe message receiver.\n\n\n\n## Description\nFires at the conclusion of receiving a message on a socket\n   via the sock_aio_read function\n\n\n\n" },
    { "name": "socket.aio_write", "doc": "## Name\nprobe::socket.aio_write — \n     Message send via sock_aio_write\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of this probe\n    \n     Socket type value\n    \n     Protocol value\n    \n     Protocol family value\n    \n     Socket flags value\n    \n     Message size in bytes\n    \n     Socket state value\n\n\n\n## Context\nThe message sender\n\n\n\n## Description\nFires at the beginning of sending a message on a socket\n   via the sock_aio_write function\n\n\n\n" },
    { "name": "socket.aio_write.return", "doc": "## Name\nprobe::socket.aio_write.return — \n     Conclusion of message send via sock_aio_write\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Socket flags value\n    \n     Socket state value\n    \n     Size of message received (in bytes) or error code if success = 0\n    \n     Socket type value\n    \n     Was receive successful? (1 = yes, 0 = no)\n    \n     Name of this probe\n    \n     Protocol value\n\n\n\n## Context\nThe message receiver.\n\n\n\n## Description\nFires at the conclusion of sending a message on a socket\n   via the sock_aio_write function\n\n\n\n" },
    { "name": "socket.close", "doc": "## Name\nprobe::socket.close — \n     Close a socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of this probe\n    \n     Socket type value\n    \n     Protocol value\n    \n     Protocol family value\n    \n     Socket state value\n    \n     Socket flags value\n\n\n\n## Context\nThe requester (user process or kernel)\n\n\n\n## Description\nFires at the beginning of closing a socket.\n\n\n\n" },
    { "name": "socket.close.return", "doc": "## Name\nprobe::socket.close.return — \n     Return from closing a socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of this probe\n\n\n\n## Context\nThe requester (user process or kernel)\n\n\n\n## Description\nFires at the conclusion of closing a socket.\n\n\n\n" },
    { "name": "socket.create", "doc": "## Name\nprobe::socket.create — \n     Creation of a socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Requested by user process or the kernel (1 = kernel, 0 = user)\n    \n     Name of this probe\n    \n     Socket type value\n    \n     Protocol value\n\n\n\n## Context\nThe requester (see requester variable)\n\n\n\n## Description\nFires at the beginning of creating a socket.\n\n\n\n" },
    { "name": "socket.create.return", "doc": "## Name\nprobe::socket.create.return — \n     Return from Creation of a socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of this probe\n    \n     Was socket creation successful? (1 = yes, 0 = no)\n    \n     Socket type value\n    \n     Protocol value\n    \n     Protocol family value\n    \n     Error code if success == 0\n    \n     Requested by user process or the kernel (1 = kernel, 0 = user)\n\n\n\n## Context\nThe requester (user process or kernel)\n\n\n\n## Description\nFires at the conclusion of creating a socket.\n\n\n\n" },
    { "name": "socket.read_iter.return", "doc": "## Name\nprobe::socket.read_iter.return — \n     Conclusion of message received via sock_read_iter\n\n\n\n## Synopsis\n\n\n\n\n## Values\nSocket type value\n    \n     Was receive successful? (1 = yes, 0 = no)\n    \n     Name of this probe\n    \n     Protocol value\n    \n     Protocol family value\n    \n     Socket state value\n    \n     Size of message received (in bytes) or error code if success = 0\n    \n     Socket flags value\n\n\n\n## Context\nThe message receiver.\n\n\n\n## Description\nFires at the conclusion of receiving a message on a socket\n   via the sock_read_iter function\n\n\n\n" },
    { "name": "socket.readv", "doc": "## Name\nprobe::socket.readv — \n     Receiving a message via sock_readv\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Socket flags value\n    \n     Socket state value\n    \n     Message size in bytes\n    \n     Name of this probe\n    \n     Socket type value\n    \n     Protocol value\n\n\n\n## Context\nThe message sender\n\n\n\n## Description\nFires at the beginning of receiving a message on a socket\n   via the sock_readv function\n\n\n\n" },
    { "name": "socket.readv.return", "doc": "## Name\nprobe::socket.readv.return — \n     Conclusion of receiving a message via sock_readv\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of this probe\n    \n     Was receive successful? (1 = yes, 0 = no)\n    \n     Socket type value\n    \n     Protocol value\n    \n     Protocol family value\n    \n     Socket state value\n    \n     Size of message received (in bytes) or error code if success = 0\n    \n     Socket flags value\n\n\n\n## Context\nThe message receiver.\n\n\n\n## Description\nFires at the conclusion of receiving a message on a socket\n   via the sock_readv function\n\n\n\n" },
    { "name": "socket.receive", "doc": "## Name\nprobe::socket.receive — \n     Message received on a socket.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nSocket state value\n    \n     Size of message received (in bytes) or error code if success = 0\n    \n     Socket flags value\n    \n     Protocol family value\n    \n     Protocol value\n    \n     Socket type value\n    \n     Was send successful? (1 = yes, 0 = no)\n    \n     Name of this probe\n\n\n\n## Context\nThe message receiver\n\n\n\n" },
    { "name": "socket.recvmsg.return", "doc": "## Name\nprobe::socket.recvmsg.return — \n     Return from Message being received on socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Socket flags value\n    \n     Size of message received (in bytes) or error code if success = 0\n    \n     Socket state value\n    \n     Name of this probe\n    \n     Was receive successful? (1 = yes, 0 = no)\n    \n     Socket type value\n    \n     Protocol value\n\n\n\n## Context\nThe message receiver.\n\n\n\n## Description\nFires at the conclusion of receiving a message on a socket\n   via the sock_recvmsg function.\n\n\n\n" },
    { "name": "socket.send", "doc": "## Name\nprobe::socket.send — \n  Message sent on a socket.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nSocket flags value\n    \n     Size of message sent (in bytes) or error code if success = 0\n    \n     Socket state value\n    \n     Protocol family value\n    \n     Protocol value\n    \n     Socket type value\n    \n     Was send successful? (1 = yes, 0 = no)\n    \n     Name of this probe\n\n\n\n## Context\nThe message sender\n\n\n\n" },
    { "name": "socket.recvmsg", "doc": "## Name\nprobe::socket.recvmsg — \n     Message being received on socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Socket flags value\n    \n     Socket state value\n    \n     Message size in bytes\n    \n     Name of this probe\n    \n     Socket type value\n    \n     Protocol value\n\n\n\n## Context\nThe message receiver.\n\n\n\n## Description\nFires at the beginning of receiving a message on a socket\n   via the sock_recvmsg function\n\n\n\n" },
    { "name": "socket.sendmsg", "doc": "## Name\nprobe::socket.sendmsg — \n     Message is currently being sent on a socket.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Socket state value\n    \n     Message size in bytes\n    \n     Socket flags value\n    \n     Name of this probe\n    \n     Socket type value\n    \n     Protocol value\n\n\n\n## Context\nThe message sender\n\n\n\n## Description\nFires at the beginning of sending a message on a socket\n   via the sock_sendmsg function\n\n\n\n" },
    { "name": "socket.sendmsg.return", "doc": "## Name\nprobe::socket.sendmsg.return — \n     Return from socket.sendmsg.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nSocket flags value\n    \n     Size of message sent (in bytes) or error code if success = 0\n    \n     Socket state value\n    \n     Protocol family value\n    \n     Protocol value\n    \n     Socket type value\n    \n     Was send successful? (1 = yes, 0 = no)\n    \n     Name of this probe\n\n\n\n## Context\nThe message sender.\n\n\n\n## Description\nFires at the conclusion of sending a message on a socket\n   via the sock_sendmsg function\n\n\n\n" },
    { "name": "socket.write_iter", "doc": "## Name\nprobe::socket.write_iter — \n     Message send via sock_write_iter\n\n\n\n## Synopsis\n\n\n\n\n## Values\nSocket type value\n    \n     Name of this probe\n    \n     Protocol value\n    \n     Protocol family value\n    \n     Socket flags value\n    \n     Socket state value\n    \n     Message size in bytes\n\n\n\n## Context\nThe message sender\n\n\n\n## Description\nFires at the beginning of sending a message on a socket\n   via the sock_write_iter function\n\n\n\n" },
    { "name": "socket.write_iter.return", "doc": "## Name\nprobe::socket.write_iter.return — \n     Conclusion of message send via sock_write_iter\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Socket flags value\n    \n     Socket state value\n    \n     Size of message received (in bytes) or error code if success = 0\n    \n     Name of this probe\n    \n     Was receive successful? (1 = yes, 0 = no)\n    \n     Socket type value\n    \n     Protocol value\n\n\n\n## Context\nThe message receiver.\n\n\n\n## Description\nFires at the conclusion of sending a message on a socket\n   via the sock_write_iter function\n\n\n\n" },
    { "name": "socket.writev", "doc": "## Name\nprobe::socket.writev — \n     Message sent via socket_writev\n\n\n\n## Synopsis\n\n\n\n\n## Values\nSocket flags value\n    \n     Socket state value\n    \n     Message size in bytes\n    \n     Protocol family value\n    \n     Protocol value\n    \n     Socket type value\n    \n     Name of this probe\n\n\n\n## Context\nThe message sender\n\n\n\n## Description\nFires at the beginning of sending a message on a socket\n   via the sock_writev function\n\n\n\n" },
    { "name": "socket.writev.return", "doc": "## Name\nprobe::socket.writev.return — \n     Conclusion of message sent via socket_writev\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Socket state value\n    \n     Size of message sent (in bytes) or error code if success = 0\n    \n     Socket flags value\n    \n     Socket type value\n    \n     Was send successful? (1 = yes, 0 = no)\n    \n     Name of this probe\n    \n     Protocol value\n\n\n\n## Context\nThe message receiver.\n\n\n\n## Description\nFires at the conclusion of sending a message on a socket\n   via the sock_writev function\n\n\n\n" },
    { "name": "socket.read_iter", "doc": "## Name\nprobe::socket.read_iter — \n     Receiving message via sock_read_iter\n\n\n\n## Synopsis\n\n\n\n\n## Values\nProtocol family value\n    \n     Socket flags value\n    \n     Socket state value\n    \n     Message size in bytes\n    \n     Name of this probe\n    \n     Socket type value\n    \n     Protocol value\n\n\n\n## Context\nThe message sender\n\n\n\n## Description\nFires at the beginning of receiving a message on a socket\n   via the sock_read_iter function\n\n\n\n" },
    { "name": "ipmib.ForwDatagrams", "doc": "## Name\nprobe::ipmib.ForwDatagrams — \n     Count forwarded packet\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sk_buff being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global ForwDatagrams (equivalent to SNMP's MIB\n   IPSTATS_MIB_OUTFORWDATAGRAMS)\n\n\n\n" },
    { "name": "ipmib.FragFails", "doc": "## Name\nprobe::ipmib.FragFails — \n     Count datagram fragmented unsuccessfully\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sk_buff being acted on\n    \n     Value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global FragFails (equivalent to SNMP's MIB\n   IPSTATS_MIB_FRAGFAILS)\n\n\n\n" },
    { "name": "ipmib.FragOKs", "doc": "## Name\nprobe::ipmib.FragOKs — \n     Count datagram fragmented successfully\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sk_buff being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global FragOKs (equivalent to SNMP's MIB\n   IPSTATS_MIB_FRAGOKS)\n\n\n\n" },
    { "name": "ipmib.InAddrErrors", "doc": "## Name\nprobe::ipmib.InAddrErrors — \n     Count arriving packets with an incorrect address\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sk_buff being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InAddrErrors (equivalent to SNMP's MIB\n   IPSTATS_MIB_INADDRERRORS)\n\n\n\n" },
    { "name": "ipmib.InReceives", "doc": "## Name\nprobe::ipmib.InReceives — \n     Count an arriving packet\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sk_buff being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InReceives (equivalent to SNMP's MIB\n   IPSTATS_MIB_INRECEIVES)\n\n\n\n" },
    { "name": "ipmib.InDiscards", "doc": "## Name\nprobe::ipmib.InDiscards — \n     Count discarded inbound packets\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sk_buff being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InDiscards (equivalent to SNMP's MIB\n   STATS_MIB_INDISCARDS)\n\n\n\n" },
    { "name": "ipmib.InUnknownProtos", "doc": "## Name\nprobe::ipmib.InUnknownProtos — \n     Count arriving packets with an unbound proto\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sk_buff being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InUnknownProtos (equivalent to SNMP's MIB\n   IPSTATS_MIB_INUNKNOWNPROTOS)\n\n\n\n" },
    { "name": "ipmib.OutRequests", "doc": "## Name\nprobe::ipmib.OutRequests — \n     Count a request to send a packet\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sk_buff being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global OutRequests (equivalent to SNMP's MIB\n   IPSTATS_MIB_OUTREQUESTS)\n\n\n\n" },
    { "name": "ipmib.ReasmReqds", "doc": "## Name\nprobe::ipmib.ReasmReqds — \n     Count number of packet fragments reassembly requests\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sk_buff being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global ReasmReqds (equivalent to SNMP's MIB\n   IPSTATS_MIB_REASMREQDS)\n\n\n\n" },
    { "name": "ipmib.ReasmTimeout", "doc": "## Name\nprobe::ipmib.ReasmTimeout — \n     Count Reassembly Timeouts\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sk_buff being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global ReasmTimeout (equivalent to SNMP's MIB\n   IPSTATS_MIB_REASMTIMEOUT)\n\n\n\n" },
    { "name": "linuxmib.DelayedACKs", "doc": "## Name\nprobe::linuxmib.DelayedACKs — \n  Count of delayed acks\n\n\n\n## Synopsis\n\n\n\n\n## Values\nPointer to the struct sock being acted on\n    \n     Value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   linuxmib_filter_key. If the packet passes the filter is is\n   counted in the global DelayedACKs (equivalent to SNMP's MIB\n   LINUX_MIB_DELAYEDACKS)\n\n\n\n" },
    { "name": "linuxmib.ListenDrops", "doc": "## Name\nprobe::linuxmib.ListenDrops — \n     Count of times conn request that were dropped\n\n\n\n## Synopsis\n\n\n\n\n## Values\nValue to be added to the counter (default value of 1)\n    \n     Pointer to the struct sock being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   linuxmib_filter_key. If the packet passes the filter is is\n   counted in the global ListenDrops (equivalent to SNMP's MIB\n   LINUX_MIB_LISTENDROPS)\n\n\n\n" },
    { "name": "linuxmib.ListenOverflows", "doc": "## Name\nprobe::linuxmib.ListenOverflows — \n     Count of times a listen queue overflowed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nPointer to the struct sock being acted on\n    \n     Value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   linuxmib_filter_key. If the packet passes the filter is is\n   counted in the global ListenOverflows (equivalent to SNMP's MIB\n   LINUX_MIB_LISTENOVERFLOWS)\n\n\n\n" },
    { "name": "linuxmib.TCPMemoryPressures", "doc": "## Name\nprobe::linuxmib.TCPMemoryPressures — \n     Count of times memory pressure was used\n\n\n\n## Synopsis\n\n\n\n\n## Values\nPointer to the struct sock being acted on\n    \n     Value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   linuxmib_filter_key. If the packet passes the filter is is\n   counted in the global TCPMemoryPressures (equivalent to SNMP's MIB\n   LINUX_MIB_TCPMEMORYPRESSURES)\n\n\n\n" },
    { "name": "tcpmib.ActiveOpens", "doc": "## Name\nprobe::tcpmib.ActiveOpens — \n     Count an active opening of a socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sock being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global ActiveOpens (equivalent to SNMP's MIB\n   TCP_MIB_ACTIVEOPENS)\n\n\n\n" },
    { "name": "tcpmib.AttemptFails", "doc": "## Name\nprobe::tcpmib.AttemptFails — \n     Count a failed attempt to open a socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sock being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global AttemptFails (equivalent to SNMP's MIB\n   TCP_MIB_ATTEMPTFAILS)\n\n\n\n" },
    { "name": "tcpmib.CurrEstab", "doc": "## Name\nprobe::tcpmib.CurrEstab — \n     Update the count of open sockets\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sock being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global CurrEstab (equivalent to SNMP's MIB\n   TCP_MIB_CURRESTAB)\n\n\n\n" },
    { "name": "tcpmib.InSegs", "doc": "## Name\nprobe::tcpmib.InSegs — \n     Count an incoming tcp segment\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sock being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key (or ipmib_filter_key for tcp v4).\n   If the packet passes the filter is is\n   counted in the global InSegs (equivalent to SNMP's MIB\n   TCP_MIB_INSEGS)\n\n\n\n" },
    { "name": "tcpmib.OutRsts", "doc": "## Name\nprobe::tcpmib.OutRsts — \n     Count the sending of a reset packet\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sock being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global OutRsts (equivalent to SNMP's MIB\n   TCP_MIB_OUTRSTS)\n\n\n\n" },
    { "name": "tcpmib.OutSegs", "doc": "## Name\nprobe::tcpmib.OutSegs — \n     Count the sending of a TCP segment\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sock being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global OutSegs (equivalent to SNMP's MIB\n   TCP_MIB_OUTSEGS)\n\n\n\n" },
    { "name": "tcpmib.PassiveOpens", "doc": "## Name\nprobe::tcpmib.PassiveOpens — \n     Count the passive creation of a socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sock being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global PassiveOpens (equivalent to SNMP's MIB\n   TCP_MIB_PASSIVEOPENS)\n\n\n\n" },
    { "name": "tcpmib.RetransSegs", "doc": "## Name\nprobe::tcpmib.RetransSegs — \n     Count the retransmission of a TCP segment\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sock being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global RetransSegs (equivalent to SNMP's MIB\n   TCP_MIB_RETRANSSEGS)\n\n\n\n" },
    { "name": "ipmib.InNoRoutes", "doc": "## Name\nprobe::ipmib.InNoRoutes — \n     Count an arriving packet with no matching socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\nvalue to be added to the counter (default value of 1)\n    \n     pointer to the struct sk_buff being acted on\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InNoRoutes (equivalent to SNMP's MIB\n   IPSTATS_MIB_INNOROUTES)\n\n\n\n" },
    { "name": "kprocess.create", "doc": "## Name\nprobe::kprocess.create — \n  Fires whenever a new process or thread is successfully created\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe TID of the newly created task\n    \n     The PID of the newly created process\n\n\n\n## Context\nParent of the created process.\n\n\n\n## Description\nFires whenever a new process is successfully created, either as a result of\n   fork (or one of its syscall variants), or a new kernel thread.\n\n\n\n" },
    { "name": "kprocess.exec", "doc": "## Name\nprobe::kprocess.exec — \n     Attempt to exec to a new program\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe arguments to pass to the new executable, including\n     the 0th arg (SystemTap v2.5+)\n    \n     A string containing the filename followed by the\n     arguments to pass, excluding 0th arg (SystemTap v2.5+)\n    \n     Name of the system call (“execve”) (SystemTap v2.5+)\n    \n     The path to the new executable\n\n\n\n## Context\nThe caller of exec.\n\n\n\n## Description\nFires whenever a process attempts to exec to a new program. Aliased\n   to the syscall.execve probe in SystemTap v2.5+.\n\n\n\n" },
    { "name": "tcpmib.EstabResets", "doc": "## Name\nprobe::tcpmib.EstabResets — \n     Count the reset of a socket\n\n\n\n## Synopsis\n\n\n\n\n## Values\npointer to the struct sock being acted on\n    \n     value to be added to the counter (default value of 1)\n\n\n\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global EstabResets (equivalent to SNMP's MIB\n   TCP_MIB_ESTABRESETS)\n\n\n\n" },
    { "name": "kprocess.exec_complete", "doc": "## Name\nprobe::kprocess.exec_complete — \n     Return from exec to a new program\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA boolean indicating whether the exec was successful\n    \n     The error number resulting from the exec\n    \n     Name of the system call (“execve”) (SystemTap v2.5+)\n    \n     A string representation of errno (SystemTap v2.5+)\n\n\n\n## Context\nOn success, the context of the new executable.\n   On failure, remains in the context of the caller.\n\n\n\n## Description\nFires at the completion of an exec call. Aliased to the\n   syscall.execve.return probe in SystemTap v2.5+.\n\n\n\n" },
    { "name": "kprocess.exit", "doc": "## Name\nprobe::kprocess.exit — \n     Exit from process\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe exit code of the process\n\n\n\n## Context\nThe process which is terminating.\n\n\n\n## Description\nFires when a process terminates.  This will always be followed by a\n   kprocess.release, though the latter may be delayed if the process waits in a\n   zombie state.\n\n\n\n" },
    { "name": "kprocess.release", "doc": "## Name\nprobe::kprocess.release — \n     Process released\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA task handle to the process being released\n    \n     TID of the task being released\n    \n     PID of the process being released\n    \n     Same as released_pid for compatibility (deprecated)\n\n\n\n## Context\nThe context of the parent, if it wanted notification of this process'\n   termination, else the context of the process itself.\n\n\n\n## Description\nFires when a process is released from the kernel.  This always follows a\n   kprocess.exit, though it may be delayed somewhat if the process waits in a\n   zombie state.\n\n\n\n" },
    { "name": "kprocess.start", "doc": "## Name\nprobe::kprocess.start — \n     Starting new process\n\n\n\n## Synopsis\n\n\n\n\n## Values\nNone\n\n\n\n## Context\nNewly created process.\n\n\n\n## Description\nFires immediately before a new process begins execution.\n\n\n\n" },
    { "name": "signal.check_ignored", "doc": "## Name\nprobe::signal.check_ignored — \n     Checking to see signal is ignored\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the process receiving the signal\n    \n     The PID of the process receiving the signal\n    \n     A string representation of the signal\n    \n     The number of the signal\n\n\n\n" },
    { "name": "signal.check_ignored.return", "doc": "## Name\nprobe::signal.check_ignored.return — \n     Check to see signal is ignored completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nReturn value as a string\n    \n     Name of the probe point\n\n\n\n" },
    { "name": "signal.checkperm", "doc": "## Name\nprobe::signal.checkperm — \n     Check being performed on a sent signal\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     The address of the siginfo structure\n    \n     A string representation of the signal\n    \n     The PID of the process receiving the signal\n    \n     Indicates the signal type\n    \n     Name of the process receiving the signal\n    \n     A task handle to the signal recipient\n    \n     The number of the signal\n\n\n\n" },
    { "name": "signal.do_action", "doc": "## Name\nprobe::signal.do_action — \n     Examining or changing a signal action\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA string representation of the signal\n    \n     The new mask of the signal\n    \n     Name of the probe point\n    \n     The new handler of the signal\n    \n     The address of the new sigaction\n     struct associated with the signal\n    \n     The address of the old sigaction\n     struct associated with the signal\n    \n     The signal to be examined/changed\n\n\n\n" },
    { "name": "signal.flush", "doc": "## Name\nprobe::signal.flush — \n     Flushing all pending signals for a task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe name of the process associated with the task\n     performing the flush\n    \n     The PID of the process associated with the task\n     performing the flush\n    \n     Name of the probe point\n    \n     The task handler of the process performing the flush\n\n\n\n" },
    { "name": "signal.do_action.return", "doc": "## Name\nprobe::signal.do_action.return — \n     Examining or changing a signal action completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     Return value as a string\n\n\n\n" },
    { "name": "signal.checkperm.return", "doc": "## Name\nprobe::signal.checkperm.return — \n     Check performed on a sent signal completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nReturn value as a string\n    \n     Name of the probe point\n\n\n\n" },
    { "name": "signal.force_segv.return", "doc": "## Name\nprobe::signal.force_segv.return — \n     Forcing send of SIGSEGV complete\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     Return value as a string\n\n\n\n" },
    { "name": "signal.force_segv", "doc": "## Name\nprobe::signal.force_segv — \n     Forcing send of SIGSEGV\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe number of the signal\n    \n     Name of the probe point\n    \n     The PID of the process receiving the signal\n    \n     A string representation of the signal\n    \n     Name of the process receiving the signal\n\n\n\n" },
    { "name": "signal.handle", "doc": "## Name\nprobe::signal.handle — \n     Signal handler being invoked\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe signal number that invoked the signal handler\n    \n     The address of the bitmask array of blocked signals\n     (deprecated in SystemTap 2.1)\n    \n     The address of the k_sigaction table\n     associated with the signal\n    \n     The address of the kernel-mode stack area (deprecated in\n     SystemTap 2.1)\n    \n     The si_code value of the siginfo signal\n    \n     A string representation of the signal\n    \n     Indicates whether the signal was a user-mode or kernel-mode signal\n    \n     Name of the probe point\n    \n     The address of the siginfo table\n\n\n\n" },
    { "name": "signal.handle.return", "doc": "## Name\nprobe::signal.handle.return — \n     Signal handler invocation completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     Return value as a string\n\n\n\n## Description\n(deprecated in SystemTap 2.1)\n\n\n\n" },
    { "name": "signal.procmask", "doc": "## Name\nprobe::signal.procmask — \n     Examining or changing blocked signals\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe actual value to be set for sigset_t\n     (correct?)\n    \n     Indicates how to change the blocked signals; possible values are\n     SIG_BLOCK=0 (for blocking signals),\n     SIG_UNBLOCK=1 (for unblocking signals), and\n     SIG_SETMASK=2 for setting the signal mask.\n    \n     Name of the probe point\n    \n     The address of the signal set (sigset_t)\n     to be implemented\n    \n     The old address of the signal set\n     (sigset_t)\n\n\n\n" },
    { "name": "signal.pending.return", "doc": "## Name\nprobe::signal.pending.return — \n     Examination of pending signal completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     Return value as a string\n\n\n\n" },
    { "name": "signal.send.return", "doc": "## Name\nprobe::signal.send.return — \n     Signal being sent to a process completed (deprecated in SystemTap 2.1)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe return value to either __group_send_sig_info, specific_send_sig_info, or send_sigqueue\n    \n     Indicates whether the sent signal was sent to an existing sigqueue\n    \n     Indicates whether the sent signal is shared by the thread group.\n    \n     The name of the function used to send out the signal\n\n\n\n## Context\nThe signal's sender. (correct?)\n\n\n\n## Description\nPossible __group_send_sig_info and\n   specific_send_sig_info return values are as follows;\n   \n\n   0 -- The signal is successfully sent to a process,\n   which means that, (1) the signal was ignored by the receiving process,\n   (2) this is a non-RT signal and the system already has one queued, and\n   (3) the signal was successfully added to the sigqueue of the receiving process.\n   \n\n   -EAGAIN -- The sigqueue of the receiving process is\n   overflowing, the signal was RT, and the signal was sent by a user using something other\n   than kill.\n   \n\n   Possible send_group_sigqueue and\n   send_sigqueue return values are as follows;\n   \n\n   0 -- The signal was either successfully added into the\n   sigqueue of the receiving process, or a SI_TIMER entry is already\n   queued (in which case, the overrun count will be simply incremented).\n   \n\n   1 -- The signal was ignored by the receiving process.\n   \n\n   -1 -- (send_sigqueue only) The task was marked\n   exiting, allowing * posix_timer_event to redirect it to the group\n   leader.\n\n\n\n" },
    { "name": "signal.send", "doc": "## Name\nprobe::signal.send — \n  Signal being sent to a process\n\n\n\n## Synopsis\n\n\n\n\n## Values\nIndicates the signal type\n    \n     The name of the signal recipient\n    \n     Indicates whether the signal is shared by the thread group\n    \n     The address of siginfo struct\n    \n     The name of the function used to send out the signal\n    \n     The PID of the process receiving the signal\n    \n     A string representation of the signal\n    \n     The number of the signal\n    \n     A task handle to the signal recipient\n    \n     Indicates whether the signal is sent to an existing\n     sigqueue (deprecated in SystemTap 2.1)\n\n\n\n## Context\nThe signal's sender.\n\n\n\n" },
    { "name": "signal.send_sig_queue", "doc": "## Name\nprobe::signal.send_sig_queue — \n     Queuing a signal to a process\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe queued signal\n    \n     Name of the probe point\n    \n     The PID of the process to which the signal is queued\n    \n     A string representation of the signal\n    \n     Name of the process to which the signal is queued\n    \n     The address of the signal queue\n\n\n\n" },
    { "name": "signal.sys_tgkill.return", "doc": "## Name\nprobe::signal.sys_tgkill.return — \n     Sending kill signal to a thread group completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe return value to either __group_send_sig_info,\n    \n     Name of the probe point\n\n\n\n" },
    { "name": "signal.sys_tgkill", "doc": "## Name\nprobe::signal.sys_tgkill — \n     Sending kill signal to a thread group\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     A string representation of the signal\n    \n     The PID of the thread receiving the kill signal\n    \n     The name of the signal recipient\n    \n     A task handle to the signal recipient\n    \n     The specific kill signal sent to the process\n    \n     The thread group ID of the thread receiving the kill signal\n\n\n\n## Description\nThe tgkill call is similar to tkill,\n   except that it also allows the caller to specify the thread group ID of\n   the thread to be signalled. This protects against TID reuse.\n\n\n\n" },
    { "name": "signal.send_sig_queue.return", "doc": "## Name\nprobe::signal.send_sig_queue.return — \n     Queuing a signal to a process completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nReturn value as a string\n    \n     Name of the probe point\n\n\n\n" },
    { "name": "signal.sys_tkill", "doc": "## Name\nprobe::signal.sys_tkill — \n     Sending a kill signal to a thread\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA task handle to the signal recipient\n    \n     The specific signal sent to the process\n    \n     Name of the probe point\n    \n     A string representation of the signal\n    \n     The PID of the process receiving the kill signal\n    \n     The name of the signal recipient\n\n\n\n## Description\nThe tkill call is analogous to kill(2),\n   except that it also allows a process within a specific thread group to\n   be targeted. Such processes are targeted through their unique\n   thread IDs (TID).\n\n\n\n" },
    { "name": "signal.syskill", "doc": "## Name\nprobe::signal.syskill — \n     Sending kill signal to a process\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA task handle to the signal recipient\n    \n     The specific signal sent to the process\n    \n     The PID of the process receiving the signal\n    \n     A string representation of the signal\n    \n     Name of the probe point\n    \n     The name of the signal recipient\n\n\n\n" },
    { "name": "signal.syskill.return", "doc": "## Name\nprobe::signal.syskill.return — \n     Sending kill signal completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nNone\n\n\n\n" },
    { "name": "signal.systkill.return", "doc": "## Name\nprobe::signal.systkill.return — \n     Sending kill signal to a thread completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     The return value to either __group_send_sig_info,\n\n\n\n" },
    { "name": "signal.wakeup", "doc": "## Name\nprobe::signal.wakeup — \n     Sleeping process being wakened for signal\n\n\n\n## Synopsis\n\n\n\n\n## Values\nA string representation indicating the mask\n     of task states to wake. Possible values are\n     TASK_INTERRUPTIBLE, TASK_STOPPED,\n     TASK_TRACED, TASK_WAKEKILL, and TASK_INTERRUPTIBLE.\n    \n     The PID of the process to wake\n    \n     Name of the process to wake\n    \n     Indicates whether to wake up a task in a\n     STOPPED or TRACED state\n\n\n\n" },
    { "name": "signal.procmask.return", "doc": "## Name\nprobe::signal.procmask.return — \n     Examining or changing blocked signals completed\n\n\n\n## Synopsis\n\n\n\n\n## Values\nName of the probe point\n    \n     Return value as a string\n\n\n\n" },
    { "name": "signal.pending", "doc": "## Name\nprobe::signal.pending — \n     Examining pending signal\n\n\n\n## Synopsis\n\n\n\n\n## Values\nThe address of the user-space signal set\n     (sigset_t)\n    \n     The size of the user-space signal set\n    \n     Name of the probe point\n\n\n\n## Description\nThis probe is used to examine a set of signals pending for delivery\n   to a specific thread. This normally occurs when the\n   do_sigpending kernel function is executed.\n\n\n\n" },
    { "name": "stap.cache_add_nss", "doc": "## Name\nprobe::stap.cache_add_nss — \n     Add NSS (Network Security Services) information to cache\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe path the .sgn file is coming from (incl filename)\n    \n     the path the .sgn file is coming from (incl filename)\n\n\n\n## Description\nFires just before the file is actually moved. Note: stap must compiled\n   with NSS support; if moving the kernel module fails, this probe will\n   not fire.\n\n\n\n" },
    { "name": "stap.cache_add_src", "doc": "## Name\nprobe::stap.cache_add_src — \n     Adding C code translation to cache\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe path the .c file is going to (incl filename)\n    \n     the path the .c file is coming from (incl filename)\n\n\n\n## Description\nFires just before the file is actually moved. Note: if moving the\n   kernel module fails, this probe will not fire.\n\n\n\n" },
    { "name": "stap.cache_clean", "doc": "## Name\nprobe::stap.cache_clean — \n     Removing file from stap cache\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe path to the .ko/.c file being removed\n\n\n\n## Description\nFires just before the call to unlink the module/source file.\n\n\n\n" },
    { "name": "stap.cache_get", "doc": "## Name\nprobe::stap.cache_get — \n     Found item in stap cache\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe path of the .ko kernel module file\n    \n     the path of the .c source file\n\n\n\n## Description\nFires just before the return of get_from_cache, when the cache grab\n   is successful.\n\n\n\n" },
    { "name": "stap.pass0", "doc": "## Name\nprobe::stap.pass0 — \n  Starting stap pass0 (parsing command line arguments)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass0 fires after command line arguments have been parsed.\n\n\n\n" },
    { "name": "stap.pass0.end", "doc": "## Name\nprobe::stap.pass0.end — \n     Finished stap pass0 (parsing command line arguments)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass0.end fires just before the gettimeofday call for pass1.\n\n\n\n" },
    { "name": "stap.pass1.end", "doc": "## Name\nprobe::stap.pass1.end — \n     Finished stap pass1 (parsing scripts)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass1.end fires just before the jump to cleanup if s.last_pass = 1.\n\n\n\n" },
    { "name": "stap.pass1a", "doc": "## Name\nprobe::stap.pass1a — \n     Starting stap pass1 (parsing user script)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass1a fires just after the call to gettimeofday, before the\n   user script is parsed.\n\n\n\n" },
    { "name": "stap.pass1b", "doc": "## Name\nprobe::stap.pass1b — \n     Starting stap pass1 (parsing library scripts)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass1b fires just before the library scripts are parsed.\n\n\n\n" },
    { "name": "stap.cache_add_mod", "doc": "## Name\nprobe::stap.cache_add_mod — \n     Adding kernel instrumentation module to cache\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe path the .ko file is going to (incl filename)\n    \n     the path the .ko file is coming from (incl filename)\n\n\n\n## Description\nFires just before the file is actually moved. Note: if moving fails,\n   cache_add_src and cache_add_nss will not fire.\n\n\n\n" },
    { "name": "stap.pass2", "doc": "## Name\nprobe::stap.pass2 — \n     Starting stap pass2 (elaboration)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass2 fires just after the call to gettimeofday, just before the \n   call to semantic_pass.\n\n\n\n" },
    { "name": "stap.pass2.end", "doc": "## Name\nprobe::stap.pass2.end — \n     Finished stap pass2 (elaboration)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass2.end fires just before the jump to cleanup if s.last_pass = 2\n\n\n\n" },
    { "name": "stap.pass3", "doc": "## Name\nprobe::stap.pass3 — \n     Starting stap pass3 (translation to C)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass3 fires just after the call to gettimeofday, just before the\n   call to translate_pass.\n\n\n\n" },
    { "name": "stap.pass3.end", "doc": "## Name\nprobe::stap.pass3.end — \n     Finished stap pass3 (translation to C)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass3.end fires just before the jump to cleanup if s.last_pass = 3\n\n\n\n" },
    { "name": "stap.pass4", "doc": "## Name\nprobe::stap.pass4 — \n     Starting stap pass4 (compile C code into kernel module)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass4 fires just after the call to gettimeofday, just before the\n   call to compile_pass.\n\n\n\n" },
    { "name": "stap.pass5", "doc": "## Name\nprobe::stap.pass5 — \n     Starting stap pass5 (running the instrumentation)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass5 fires just after the call to gettimeofday, just before the\n   call to run_pass.\n\n\n\n" },
    { "name": "stap.pass4.end", "doc": "## Name\nprobe::stap.pass4.end — \n     Finished stap pass4 (compile C code into kernel module)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass4.end fires just before the jump to cleanup if s.last_pass = 4\n\n\n\n" },
    { "name": "stap.pass5.end", "doc": "## Name\nprobe::stap.pass5.end — \n     Finished stap pass5 (running the instrumentation)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass5.end fires just before the cleanup label\n\n\n\n" },
    { "name": "stap.pass6", "doc": "## Name\nprobe::stap.pass6 — \n     Starting stap pass6 (cleanup)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass6 fires just after the cleanup label, essentially the same spot\n   as pass5.end\n\n\n\n" },
    { "name": "stap.pass6.end", "doc": "## Name\nprobe::stap.pass6.end — \n     Finished stap pass6 (cleanup)\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe systemtap_session variable s\n\n\n\n## Description\npass6.end fires just before main's return.\n\n\n\n" },
    { "name": "stap.system", "doc": "## Name\nprobe::stap.system — \n     Starting a command from stap\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe command string to be run by posix_spawn (as sh -c <str>)\n\n\n\n## Description\nFires at the entry of the stap_system command.\n\n\n\n" },
    { "name": "stap.system.spawn", "doc": "## Name\nprobe::stap.system.spawn — \n     stap spawned new process\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe pid of the spawned process\n    \n     the return value from posix_spawn\n\n\n\n## Description\nFires just after the call to posix_spawn.\n\n\n\n" },
    { "name": "staprun.remove_module", "doc": "## Name\nprobe::staprun.remove_module — \n     Removing SystemTap instrumentation module\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe stap module name to be removed (without the .ko extension)\n\n\n\n## Description\nFires just before the call to remove the module.\n\n\n\n" },
    { "name": "stapio.receive_control_message", "doc": "## Name\nprobe::stapio.receive_control_message — \n     Received a control message\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe length (in bytes) of the data blob\n    \n     a ptr to a binary blob of data sent as the control message\n    \n     type of message being send; defined in runtime/transport/transport_msgs.h\n\n\n\n## Description\nFires just after a message was receieved and before it's processed.\n\n\n\n" },
    { "name": "staprun.insert_module", "doc": "## Name\nprobe::staprun.insert_module — \n     Inserting SystemTap instrumentation module\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe full path to the .ko kernel module about to be inserted\n\n\n\n## Description\nFires just before the call to insert the module.\n\n\n\n" },
    { "name": "stap.system.return", "doc": "## Name\nprobe::stap.system.return — \n     Finished a command from stap\n\n\n\n## Synopsis\n\n\n\n\n## Values\na return code associated with running waitpid on the spawned process; \n     a non-zero value indicates error\n\n\n\n## Description\nFires just before the return of the stap_system function, after waitpid.\n\n\n\n" },
    { "name": "nfs.aop.readpage", "doc": "## Name\nprobe::nfs.aop.readpage — \n     NFS client synchronously reading a page\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile argument\n    \n     file length in bytes\n    \n     number of pages to be read in this execution \n    \n     the address of page\n    \n     super block flags\n    \n     inode number\n    \n     offset within mapping, can used a page identifier\n     and position identifier in the page frame\n    \n     file flags\n    \n     read size  (in bytes)\n    \n     device identifier\n\n\n\n## Description\nRead the page over, only fires when a previous async\n   read operation failed\n\n\n\n" },
    { "name": "nfs.aop.write_begin", "doc": "## Name\nprobe::nfs.aop.write_begin — \n     NFS client begin to write data\n\n\n\n## Synopsis\n\n\n\n\n## Values\nwrite bytes\n    \n     start address of this write operation \n    \n     offset within mapping, can used a page identifier\n     and position identifier in the page frame\n    \n     inode number \n    \n     the address of page\n    \n     device identifier\n    \n     end address of this write operation\n\n\n\n## Description\nOccurs when write operation occurs on nfs. It prepare a page for writing,\n   look for a request corresponding to the page. If there\n   is one, and it belongs to another file, it flush it out\n   before it tries to copy anything into the page. \n   Also do the same if it finds a request from an existing\n   dropped page\n\n\n\n" },
    { "name": "nfs.aop.set_page_dirty", "doc": "## Name\nprobe::nfs.aop.set_page_dirty — \n     NFS client marking page as dirty\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe address of page\n    \n     page flags\n\n\n\n## Description\nThis probe attaches to the generic __set_page_dirty_nobuffers function.\n   Thus, this probe is going to fire on many other file systems in\n   addition to the NFS client.\n\n\n\n" },
    { "name": "nfs.aop.readpages", "doc": "## Name\nprobe::nfs.aop.readpages — \n     NFS client reading multiple pages\n\n\n\n## Synopsis\n\n\n\n\n## Values\nnumber of pages attempted to read in this execution\n    \n     read size (in pages)\n    \n     filp argument\n    \n     read size (in bytes)\n    \n     device identifier\n    \n     inode number   \n    \n     number of pages attempted to read in this execution\n\n\n\n## Description\nFires when in readahead way, read several pages once\n\n\n\n" },
    { "name": "nfs.aop.write_end", "doc": "## Name\nprobe::nfs.aop.write_end — \n     NFS client complete writing data\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile length in bytes\n    \n     write bytes\n    \n     start address of this write operation\n    \n     file flags\n    \n     end address of this write operation\n    \n     offset within mapping, can used a page identifier and position identifier in the page frame\n    \n     inode number\n    \n     the address of page\n    \n     super block flags\n    \n     device identifier\n\n\n\n## Description\nFires when do a write operation on nfs,\n   often after prepare_write\n   \n\n   Update and possibly write a cached page of an NFS file.\n\n\n\n" },
    { "name": "nfs.aop.release_page", "doc": "## Name\nprobe::nfs.aop.release_page — \n     NFS client releasing page\n\n\n\n## Synopsis\n\n\n\n\n## Values\nrelease pages\n    \n     device identifier\n    \n     offset within mapping, can used a page identifier\n     and position identifier in the page frame\n    \n     inode number\n    \n     the address of page\n\n\n\n## Description\nFires when do a release operation on NFS.\n\n\n\n" },
    { "name": "nfs.aop.writepages", "doc": "## Name\nprobe::nfs.aop.writepages — \n     NFS client writing several dirty pages to the NFS server\n\n\n\n## Synopsis\n\n\n\n\n## Values\na flag of writeback_control,\n     indicates if it's invoked from the page allocator\n    \n     write size (in pages)\n    \n     number of pages attempted to be written in this execution\n    \n     write size\n    \n     a flag of writeback_control,\n     indicates if it's a kupdate writeback\n    \n     number of pages attempted to be written in this execution\n    \n     inode number\n    \n     device identifier\n\n\n\n## Description\nThe priority of wb is decided by the flags\n   for_reclaim and for_kupdate.\n\n\n\n" },
    { "name": "nfs.aop.writepage", "doc": "## Name\nprobe::nfs.aop.writepage — \n     NFS client writing a mapped page to the NFS server\n\n\n\n## Synopsis\n\n\n\n\n## Values\nwrite size\n    \n     file flags\n    \n     a flag of writeback_control,\n     indicates if it's invoked from the page allocator\n    \n     number of pages to be written in this execution\n    \n     file length in bytes\n    \n     device identifier\n    \n     the address of page\n    \n     super block flags\n    \n     offset within mapping,\n     can used a page identifier and position identifier in the page frame\n    \n     inode number  \n    \n     a flag of writeback_control,\n     indicates if it's a kupdate writeback\n    \n     inode state flags\n\n\n\n## Description\nThe priority of wb is decided by the flags\n   for_reclaim and for_kupdate.\n\n\n\n" },
    { "name": "staprun.send_control_message", "doc": "## Name\nprobe::staprun.send_control_message — \n     Sending a control message\n\n\n\n## Synopsis\n\n\n\n\n## Values\na ptr to a binary blob of data sent as the control message\n    \n     the length (in bytes) of the data blob\n    \n     type of message being send; defined in runtime/transport/transport_msgs.h\n\n\n\n## Description\nFires at the beginning of the send_request function.\n\n\n\n" },
    { "name": "nfs.fop.aio_read", "doc": "## Name\nprobe::nfs.fop.aio_read — \n     NFS client aio_read file operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nread bytes\n    \n     inode number        \n    \n     device identifier\n    \n     the address of buf in user space\n    \n     cache related bit mask flag\n    \n     file name\n    \n     current position of file   \n    \n     parent dir name\n    \n     when we started read-caching this inode\n    \n     how long the cached information is assumed to be valid.\n     We need to revalidate the cached attrs for this inode\n     if jiffies - read_cache_jiffies > attrtimeo.\n\n\n\n" },
    { "name": "nfs.fop.check_flags", "doc": "## Name\nprobe::nfs.fop.check_flags — \n     NFS client checking flag operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile flag\n\n\n\n" },
    { "name": "nfs.fop.llseek", "doc": "## Name\nprobe::nfs.fop.llseek — \n  NFS client llseek operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe offset of the file will be repositioned\n    \n     device identifier\n    \n     inode number\n    \n     symbolic string representation of the position to seek from\n    \n     the position to seek from\n\n\n\n" },
    { "name": "nfs.fop.lock", "doc": "## Name\nprobe::nfs.fop.lock — \n     NFS client file lock operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nlock flags\n    \n     starting offset of locked region\n    \n     ending offset of locked region\n    \n     lock type\n    \n     device identifier\n    \n     inode number\n    \n     cmd arguments\n    \n     file type and access rights\n\n\n\n" },
    { "name": "nfs.fop.mmap", "doc": "## Name\nprobe::nfs.fop.mmap — \n     NFS client mmap operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nparent dir name\n    \n     when we started read-caching this inode\n    \n     the first byte after end address within vm_mm\n    \n     how long the cached information is assumed to be valid.\n     We need to revalidate the cached attrs for this inode \n     if jiffies - read_cache_jiffies > attrtimeo.\n    \n     start address within vm_mm \n    \n     inode number        \n    \n     vm flags\n    \n     the address of buf in user space\n    \n     device identifier\n    \n     cache related bit mask flag\n    \n     file name\n\n\n\n" },
    { "name": "nfs.fop.read", "doc": "## Name\nprobe::nfs.fop.read — \n     NFS client read operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nblock device name\n\n\n\n## Description\nSystemTap uses the vfs.do_sync_read probe to implement this probe\n   and as a result will get operations other than the NFS client read\n   operations.\n\n\n\n" },
    { "name": "nfs.fop.open", "doc": "## Name\nprobe::nfs.fop.open — \n     NFS client file open operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile length in bytes \n    \n     file flag\n    \n     device identifier\n    \n     file name\n    \n     inode number\n\n\n\n" },
    { "name": "nfs.fop.aio_write", "doc": "## Name\nprobe::nfs.fop.aio_write — \n     NFS client aio_write file operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\noffset of the file \n    \n     parent dir name\n    \n     read bytes\n    \n     inode number        \n    \n     device identifier\n    \n     the address of buf in user space\n    \n     file name\n\n\n\n" },
    { "name": "nfs.fop.release", "doc": "## Name\nprobe::nfs.fop.release — \n     NFS client release page operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\ninode number\n    \n     file mode\n    \n     device identifier\n\n\n\n" },
    { "name": "nfs.fop.read_iter", "doc": "## Name\nprobe::nfs.fop.read_iter — \n     NFS client read_iter file operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nwhen we started read-caching this inode\n    \n     how long the cached information is assumed to be valid.\n     We need to revalidate the cached attrs for this inode\n     if jiffies - read_cache_jiffies > attrtimeo.\n    \n     current position of file   \n    \n     parent dir name\n    \n     read bytes\n    \n     inode number        \n    \n     device identifier\n    \n     file name\n    \n     cache related bit mask flag\n\n\n\n" },
    { "name": "nfs.fop.sendfile", "doc": "## Name\nprobe::nfs.fop.sendfile — \n     NFS client send file operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nhow long the cached information is assumed to be valid.\n     We need to revalidate the cached attrs for this inode\n     if jiffies - read_cache_jiffies > attrtimeo.\n    \n     when we started read-caching this inode\n    \n     device identifier\n    \n     cache related bit mask flag\n    \n     inode number\n    \n     read bytes\n    \n     current position of file\n\n\n\n" },
    { "name": "nfs.fop.write", "doc": "## Name\nprobe::nfs.fop.write — \n     NFS client write operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\nblock device name\n\n\n\n## Description\nSystemTap uses the vfs.do_sync_write probe to implement this probe\n   and as a result will get operations other than the NFS client write\n   operations.\n\n\n\n" },
    { "name": "nfs.fop.fsync", "doc": "## Name\nprobe::nfs.fop.fsync — \n     NFS client fsync operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\ninode number\n    \n     number of dirty pages\n    \n     device identifier\n\n\n\n" },
    { "name": "nfs.fop.write_iter", "doc": "## Name\nprobe::nfs.fop.write_iter — \n     NFS client write_iter file operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\noffset of the file \n    \n     parent dir name\n    \n     inode number        \n    \n     read bytes\n    \n     device identifier\n    \n     file name\n\n\n\n" },
    { "name": "nfs.proc.commit", "doc": "## Name\nprobe::nfs.proc.commit — \n     NFS client committing data on server\n\n\n\n## Synopsis\n\n\n\n\n## Values\nV4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     read bytes in this execution\n    \n     the file offset\n    \n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     IP address of server\n    \n     transfer protocol\n    \n     NFS version\n\n\n\n## Description\nAll the nfs.proc.commit kernel functions were removed in kernel\n   commit 200baa in December 2006, so these probes do not exist on Linux\n   2.6.21 and newer kernels.\n   \n\n   Fires when client writes the buffered data to disk.\n   The buffered data is asynchronously written by client earlier.\n   The commit function works in sync way.\n   This probe point does not exist in NFSv2.\n\n\n\n" },
    { "name": "nfs.proc.commit_done", "doc": "## Name\nprobe::nfs.proc.commit_done — \n     NFS client response to a commit RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfattr->valid, indicates which fields are valid \n    \n     IP address of server\n    \n     NFS version\n    \n     transfer protocol\n    \n     V4 timestamp, which is used for lease renewal\n    \n     result of last operation\n    \n     number of bytes committed\n\n\n\n## Description\nFires when a reply to a commit RPC task is received\n   or some commit operation error occur (timeout or socket shutdown).\n\n\n\n" },
    { "name": "nfs.fop.flush", "doc": "## Name\nprobe::nfs.fop.flush — \n     NFS client flush file operation\n\n\n\n## Synopsis\n\n\n\n\n## Values\ndevice identifier\n    \n     number of dirty page\n    \n     file mode\n    \n     inode number\n\n\n\n" },
    { "name": "nfs.proc.commit_setup", "doc": "## Name\nprobe::nfs.proc.commit_setup — \n     NFS client setting up a commit RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nV4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     bytes in this commit\n    \n     bytes in this commit\n    \n     the file offset\n    \n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     IP address of server\n    \n     transfer protocol\n    \n     NFS version\n\n\n\n## Description\nThe commit_setup function is used to setup a commit RPC task.\n   Is is not doing the actual commit operation.\n   It does not exist in NFSv2.\n\n\n\n" },
    { "name": "nfs.proc.create", "doc": "## Name\nprobe::nfs.proc.create — \n     NFS client creating file on server\n\n\n\n## Synopsis\n\n\n\n\n## Values\nlength of file name\n    \n     file handle of parent dir\n    \n     indicates create mode (only for NFSv3 and NFSv4)\n    \n     file name\n    \n     IP address of server\n    \n     NFS version (the function is used for all NFS version)\n    \n     transfer protocol\n\n\n\n" },
    { "name": "nfs.proc.lookup", "doc": "## Name\nprobe::nfs.proc.lookup — \n  NFS client opens/searches a file on server\n\n\n\n## Synopsis\n\n\n\n\n## Values\nV4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     the name of file which client opens/searches on server\n    \n     IP address of server\n    \n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     the length of file name\n    \n     transfer protocol\n    \n     NFS version\n\n\n\n" },
    { "name": "nfs.proc.handle_exception", "doc": "## Name\nprobe::nfs.proc.handle_exception — \n     NFS client handling an NFSv4 exception\n\n\n\n## Synopsis\n\n\n\n\n## Values\nindicates the type of error\n\n\n\n## Description\nThis is the error handling routine for processes for NFSv4.\n\n\n\n" },
    { "name": "nfs.proc.open", "doc": "## Name\nprobe::nfs.proc.open — \n     NFS client allocates file read/write context information\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile flag\n    \n     file mode\n    \n     transfer protocol\n    \n     NFS version (the function is used for all NFS version)\n    \n     file name\n    \n     IP address of server\n\n\n\n## Description\nAllocate file read/write context information\n\n\n\n" },
    { "name": "nfs.proc.read", "doc": "## Name\nprobe::nfs.proc.read — \n     NFS client synchronously reads file from server\n\n\n\n## Synopsis\n\n\n\n\n## Values\nIP address of server\n    \n     transfer protocol\n    \n     NFS version\n    \n     read bytes in this execution\n    \n     the file offset\n    \n     used to set task->tk_flags in rpc_init_task function\n\n\n\n## Description\nAll the nfs.proc.read kernel functions were removed in kernel commit\n   8e0969 in December 2006, so these probes do not exist on Linux\n   2.6.21 and newer kernels.\n\n\n\n" },
    { "name": "nfs.proc.read_done", "doc": "## Name\nprobe::nfs.proc.read_done — \n     NFS client response to a read RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\ntransfer protocol\n    \n     NFS version\n    \n     IP address of server\n    \n     result of last operation\n    \n     number of bytes read\n    \n     V4 timestamp, which is used for lease renewal\n\n\n\n## Description\nFires when a reply to a read RPC task is received or some read error occurs\n   (timeout or socket shutdown).\n\n\n\n" },
    { "name": "nfs.proc.read_setup", "doc": "## Name\nprobe::nfs.proc.read_setup — \n     NFS client setting up a read RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nread bytes in this execution\n    \n     read bytes in this execution\n    \n     the file offset \n    \n     IP address of server\n    \n     transfer protocol\n    \n     NFS version\n\n\n\n## Description\nThe read_setup function is used to setup a read RPC task.\n   It is not doing the actual read operation.\n\n\n\n" },
    { "name": "nfs.proc.rename", "doc": "## Name\nprobe::nfs.proc.rename — \n     NFS client renames a file on server\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile handle of new parent dir\n    \n     length of new file name\n    \n     file handle of old parent dir\n    \n     length of old file name\n    \n     NFS version (the function is used for all NFS version)\n    \n     old file name\n    \n     transfer protocol\n    \n     new file name\n    \n     IP address of server\n\n\n\n" },
    { "name": "nfs.proc.rename_done", "doc": "## Name\nprobe::nfs.proc.rename_done — \n     NFS client response to a rename RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile handle of new parent dir\n    \n     result of last operation\n    \n     file handle of old parent dir\n    \n     V4 timestamp, which is used for lease renewal\n    \n     NFS version\n    \n     transfer protocol\n    \n     IP address of server\n\n\n\n## Description\nFires when a reply to a rename RPC task is received or some rename\n   error occurs (timeout or socket shutdown).\n\n\n\n" },
    { "name": "nfs.proc.rename_setup", "doc": "## Name\nprobe::nfs.proc.rename_setup — \n     NFS client setting up a rename RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile handle of parent dir\n    \n     transfer protocol\n    \n     NFS version\n    \n     IP address of server\n\n\n\n## Description\nThe rename_setup function is used to setup a rename RPC task.\n   Is is not doing the actual rename operation.\n\n\n\n" },
    { "name": "nfs.proc.write", "doc": "## Name\nprobe::nfs.proc.write — \n     NFS client synchronously writes file to server\n\n\n\n## Synopsis\n\n\n\n\n## Values\nused to set task->tk_flags in rpc_init_task function\n    \n     the file offset\n    \n     read bytes in this execution\n    \n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     NFS version\n    \n     transfer protocol\n    \n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     IP address of server\n\n\n\n## Description\nAll the nfs.proc.write kernel functions were removed in kernel commit\n   200baa in December 2006, so these probes do not exist on Linux\n   2.6.21 and newer kernels.\n\n\n\n" },
    { "name": "nfs.proc.write_done", "doc": "## Name\nprobe::nfs.proc.write_done — \n     NFS client response to a write RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\ntransfer protocol\n    \n     NFS version\n    \n     fattr->valid, indicates which fields are valid \n    \n     IP address of server\n    \n     result of last operation\n    \n     number of bytes written\n    \n     V4 timestamp, which is used for lease renewal\n\n\n\n## Description\nFires when a reply to a write RPC task is received or some write error occurs\n   (timeout or socket shutdown).\n\n\n\n" },
    { "name": "nfs.proc.write_setup", "doc": "## Name\nprobe::nfs.proc.write_setup — \n     NFS client setting up a write RPC task\n\n\n\n## Synopsis\n\n\n\n\n## Values\nbytes written in this execution\n    \n     V4 bitmask representing the set of attributes supported\n     on this filesystem \n    \n     used to set args.stable. The stable value could be:\n     NFS_UNSTABLE,NFS_DATA_SYNC,NFS_FILE_SYNC\n     (in nfs.proc3.write_setup and nfs.proc4.write_setup)\n    \n     the file offset\n    \n     bytes written in this execution\n    \n     IP address of server\n    \n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    \n     NFS version\n    \n     transfer protocol\n\n\n\n## Description\nThe write_setup function is used to setup a write RPC task.\n   It is not doing the actual write operation.\n\n\n\n" },
    { "name": "nfsd.close", "doc": "## Name\nprobe::nfsd.close — \n     NFS server closing a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile name\n\n\n\n## Description\nThis probe point does not exist in kernels starting with 4.2.\n\n\n\n" },
    { "name": "nfsd.commit", "doc": "## Name\nprobe::nfsd.commit — \n     NFS server committing all pending writes to stable storage\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe offset of file\n    \n     read bytes\n    \n     file handle (the first part is the length of the file handle)\n    \n     read bytes\n    \n     indicates whether this execution is a sync operation\n    \n     the ip address of client\n\n\n\n" },
    { "name": "nfsd.create", "doc": "## Name\nprobe::nfsd.create — \n     NFS server creating a file(regular,dir,device,fifo) for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe ip address of client\n    \n     file type(regular,dir,device,fifo ...)\n    \n     Attribute flags\n    \n     file name \n    \n     file access mode\n    \n     the length of file name\n    \n     file handle (the first part is the length of the file handle)\n\n\n\n## Description\nSometimes nfsd will call nfsd_create_v3 instead of this this probe point.\n\n\n\n" },
    { "name": "nfsd.createv3", "doc": "## Name\nprobe::nfsd.createv3 — \n     NFS server creating a regular file or set file attributes for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile name \n    \n     Attribute flags\n    \n     file attributes (atime,mtime,mode). It's used to reset file attributes for CREATE_EXCLUSIVE\n    \n     the ip address of client\n    \n     file handle (the first part is the length of the file handle)\n    \n     trunp arguments, indicates if the file shouldbe truncate\n    \n     the length of file name\n    \n     create mode .The possible values could be: NFS3_CREATE_EXCLUSIVE, NFS3_CREATE_UNCHECKED, or NFS3_CREATE_GUARDED\n    \n     file access mode\n\n\n\n## Description\nThis probepoints is only called by nfsd3_proc_create and\n   nfsd4_open when op_claim_type is NFS4_OPEN_CLAIM_NULL.\n\n\n\n" },
    { "name": "nfsd.dispatch", "doc": "## Name\nprobe::nfsd.dispatch — \n  NFS server receives an operation from client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nprogram number\n    \n     transmission id\n    \n     procedure number\n    \n     nfs version\n    \n     transfer protocol\n    \n     the ip address of client\n\n\n\n" },
    { "name": "nfsd.lookup", "doc": "## Name\nprobe::nfsd.lookup — \n     NFS server opening or searching file for a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe ip address of client\n    \n     file name \n    \n     the length of file name\n    \n     file handle of parent dir(the first part is the length of the file handle)\n\n\n\n" },
    { "name": "nfsd.open", "doc": "## Name\nprobe::nfsd.open — \n     NFS server opening a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile handle (the first part is the length of the file handle)\n    \n     the ip address of client\n    \n     type of file (regular file or dir)\n    \n     indicates the type of open (read/write/commit/readdir...)\n\n\n\n" },
    { "name": "nfsd.proc.create", "doc": "## Name\nprobe::nfsd.proc.create — \n     NFS server creating a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nlength of file name\n    \n     requester's group id\n    \n     transfer protocol\n    \n     requester's user id\n    \n     file handle (the first part is the length of the file handle)\n    \n     the ip address of client\n    \n     nfs version\n    \n     file name\n\n\n\n" },
    { "name": "nfsd.proc.lookup", "doc": "## Name\nprobe::nfsd.proc.lookup — \n     NFS server opening or searching for a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\ntransfer protocol\n    \n     file handle of parent dir (the first part is the length of the file handle)\n    \n     file name \n    \n     requester's user id\n    \n     the length of file name\n    \n     nfs version\n    \n     the ip address of client\n    \n     requester's group id\n\n\n\n" },
    { "name": "nfsd.proc.remove", "doc": "## Name\nprobe::nfsd.proc.remove — \n     NFS server removing a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile name\n    \n     nfs version\n    \n     the ip address of client\n    \n     transfer protocol\n    \n     file handle (the first part is the length of the file handle)\n    \n     requester's user id\n    \n     length of file name\n    \n     requester's group id\n\n\n\n" },
    { "name": "nfsd.proc.read", "doc": "## Name\nprobe::nfsd.proc.read — \n     NFS server reading file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nread blocks \n    \n     requester's group id\n    \n     struct kvec, includes buf address in kernel address and length of each buffer\n    \n     nfs version\n    \n     the ip address of client\n    \n     read bytes\n    \n     file handle (the first part is the length of the file handle)\n    \n     requester's user id\n    \n     read bytes\n    \n     the offset of file \n    \n     transfer protocol\n\n\n\n" },
    { "name": "nfsd.proc.write", "doc": "## Name\nprobe::nfsd.proc.write — \n     NFS server writing data to file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe ip address of client\n    \n     nfs version\n    \n     struct kvec, includes buf address in kernel address and length of each buffer\n    \n     argp->stable\n    \n     read blocks \n    \n     requester's group id\n    \n     transfer protocol\n    \n     the offset of file \n    \n     read bytes\n    \n     requester's user id\n    \n     file handle (the first part is the length of the file handle)\n    \n     read bytes\n\n\n\n" },
    { "name": "nfsd.read", "doc": "## Name\nprobe::nfsd.read — \n     NFS server reading data from a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nstruct kvec, includes buf address in kernel address and length of each buffer\n    \n     the ip address of client\n    \n     read blocks \n    \n     argument file, indicates if the file has been opened.\n    \n     the offset of file \n    \n     file handle (the first part is the length of the file handle)\n    \n     read bytes\n    \n     read bytes\n\n\n\n" },
    { "name": "nfsd.unlink", "doc": "## Name\nprobe::nfsd.unlink — \n     NFS server removing a file or a directory for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nthe ip address of client\n    \n     file type (file or dir)\n    \n     file name \n    \n     the length of file name\n    \n     file handle (the first part is the length of the file handle)\n\n\n\n" },
    { "name": "nfsd.write", "doc": "## Name\nprobe::nfsd.write — \n     NFS server writing data to a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nargument file, indicates if the file has been opened.\n    \n     the offset of file \n    \n     read bytes\n    \n     file handle (the first part is the length of the file handle)\n    \n     read bytes\n    \n     struct kvec, includes buf address in kernel address and length of each buffer\n    \n     the ip address of client\n    \n     read blocks\n\n\n\n" },
    { "name": "nfs.proc.release", "doc": "## Name\nprobe::nfs.proc.release — \n     NFS client releases file read/write context information\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile mode\n    \n     file flag\n    \n     file name\n    \n     IP address of server\n    \n     NFS version (the function is used for all NFS version)\n    \n     transfer protocol\n\n\n\n## Description\nRelease file read/write context information\n\n\n\n" },
    { "name": "nfs.proc.remove", "doc": "## Name\nprobe::nfs.proc.remove — \n     NFS client removes a file on server\n\n\n\n## Synopsis\n\n\n\n\n## Values\nfile handle of parent dir\n    \n     length of file name\n    \n     transfer protocol\n    \n     NFS version (the function is used for all NFS version)\n    \n     IP address of server\n    \n     file name\n\n\n\n" },
    { "name": "nfsd.rename", "doc": "## Name\nprobe::nfsd.rename — \n     NFS server renaming a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nold file name \n    \n     length of new file name\n    \n     the ip address of client\n    \n     length of old file name \n    \n     file handler of old path\n    \n     file handler of new path\n    \n     new file name\n\n\n\n" },
    { "name": "nfsd.proc.commit", "doc": "## Name\nprobe::nfsd.proc.commit — \n     NFS server performing a commit operation for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nnfs version\n    \n     the ip address of client\n    \n     transfer protocol\n    \n     read bytes\n    \n     file handle (the first part is the length of the file handle)\n    \n     read bytes\n    \n     requester's user id\n    \n     the offset of file \n    \n     requester's group id\n\n\n\n" },
    { "name": "nfsd.proc.rename", "doc": "## Name\nprobe::nfsd.proc.rename — \n     NFS Server renaming a file for client\n\n\n\n## Synopsis\n\n\n\n\n## Values\nrequester's group id\n    \n     file handler of old path\n    \n     requester's user id\n    \n     new file name\n    \n     file handler of new path\n    \n     length of new file name\n    \n     the ip address of client\n    \n     length of old file name \n    \n     old file name\n\n\n\n" },
    { "name": "json_data", "doc": "## Name\nprobe::json_data — \n     Fires whenever JSON data is wanted by a reader.\n\n\n\n## Synopsis\n\n\n\n\n## Values\nNone\n\n\n\n## Context\nThis probe fires when the JSON data is about to be read. This\n   probe must gather up data and then call the following macros to\n   output the data in JSON format. First, @json_output_data_start\n   must be called. That call is followed by one or more of the\n   following (one call for each data item):\n   @json_output_string_value, @json_output_numeric_value,\n   @json_output_array_string_value, and\n   @json_output_array_numeric_value. Finally @json_output_data_end\n   must be called.\n\n\n\n" },
    { "name": "syscall_any", "doc": "## Name\nprobe::syscall_any — \n  Record entry into a syscall\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the syscall\n    \n     number of the syscall\n\n\n\n## Context\nThe process performing the syscall\n\n\n\n## Description\nThe syscall_any probe point is designed to be a low overhead\n   that monitors all the syscalls entered via a kernel tracepoint.\n   Because of the breadth of syscalls it monitors it provides\n   no information about the syscall arguments or argstr string\n   representation of those arguments.\n   \n\n   This requires kernel 3.5+ and newer which have the\n   kernel.trace(“sys_enter”) probe point.\n\n\n\n" },
    { "name": "syscall_any.return", "doc": "## Name\nprobe::syscall_any.return — \n     Record exit from a syscall\n\n\n\n## Synopsis\n\n\n\n\n## Values\nname of the syscall\n    \n     number of the syscall\n    \n     return value of the syscall\n\n\n\n## Context\nThe process performing the syscall\n\n\n\n## Description\nThe syscall_any.return probe point is designed to be a low overhead\n   that monitors all the syscalls returns via a kernel tracepoint.\n   Because of the breadth of syscalls it monitors it provides\n   no information about the syscall arguments, argstr string\n   representation of those arguments, or a string interpretation\n   of the return value (retval).\n   \n\n   This requires kernel 3.5+ and newer which have the\n   kernel.trace(“sys_exit”) probe point.\n\n\n\n" },
];
