export default [
    { "name": "vm.brk", "doc": "## Name\nprobe::vm.brk — \n     Fires when a brk is requested (i.e. the heap will be resized)\n## Synopsis\n```\nvm.brk \n```\n## Values\naddress\n     the requested address\n    name\n     name of the probe point\n    length\n     the length of the memory segment\n## Context\nThe process calling brk.\n" },
    { "name": "vm.kfree", "doc": "## Name\nprobe::vm.kfree — \n     Fires when kfree is requested\n## Synopsis\n```\nvm.kfree \n```\n## Values\ncall_site\n     address of the function calling this kmemory function\n    ptr\n     pointer to the kmemory allocated which is returned by kmalloc\n    name\n     name of the probe point\n    caller_function\n     name of the caller function.\n" },
    { "name": "vm.kmalloc", "doc": "## Name\nprobe::vm.kmalloc — \n     Fires when kmalloc is requested\n## Synopsis\n```\nvm.kmalloc \n```\n## Values\nbytes_alloc\n     allocated Bytes\n    name\n     name of the probe point\n    caller_function\n     name of the caller function\n    call_site\n     address of the kmemory function\n    gfp_flag_name\n     type of kmemory to allocate (in String format)\n    bytes_req\n     requested Bytes\n    ptr\n     pointer to the kmemory allocated\n    gfp_flags\n     type of kmemory to allocate\n" },
    { "name": "vm.mmap", "doc": "## Name\nprobe::vm.mmap — \n     Fires when an mmap is requested\n## Synopsis\n```\nvm.mmap \n```\n## Values\nlength\n     the length of the memory segment \n    name\n     name of the probe point\n    address\n     the requested address\n## Context\nThe process calling mmap.\n" },
    { "name": "vm.munmap", "doc": "## Name\nprobe::vm.munmap — \n     Fires when an munmap is requested\n## Synopsis\n```\nvm.munmap \n```\n## Values\naddress\n     the requested address\n    name\n     name of the probe point\n    length\n     the length of the memory segment\n## Context\nThe process calling munmap.\n" },
    { "name": "vm.pagefault.return", "doc": "## Name\nprobe::vm.pagefault.return — \n     Indicates what type of fault occurred\n## Synopsis\n```\nvm.pagefault.return \n```\n## Values\nfault_type\n     returns either \n     0 (VM_FAULT_OOM) for out of memory faults, \n     2 (VM_FAULT_MINOR) for minor faults, 3 (VM_FAULT_MAJOR) for \n     major faults, or 1 (VM_FAULT_SIGBUS) if the fault was neither OOM, minor fault, \n     nor major fault.\n    name\n     name of the probe point\n" },
    { "name": "vm.write_shared", "doc": "## Name\nprobe::vm.write_shared — \n     Attempts at writing to a shared page\n## Synopsis\n```\nvm.write_shared \n```\n## Values\naddress\n     the address of the shared write\n    name\n     name of the probe point\n## Context\nThe context is the process attempting the write.\n## Description\nFires when a process attempts to write to a shared page. \n   If a copy is necessary, this will be followed by a \n   vm.write_shared_copy.\n" },
    { "name": "vm.write_shared_copy", "doc": "## Name\nprobe::vm.write_shared_copy — \n     Page copy for shared page write\n## Synopsis\n```\nvm.write_shared_copy \n```\n## Values\naddress\n     The address of the shared write\n    zero\n     boolean indicating whether it is a zero page\n     (can do a clear instead of a copy)\n    name\n     Name of the probe point\n## Context\nThe process attempting the write.\n## Description\nFires when a write to a shared page requires a page copy.  This is\n   always preceded by a vm.write_shared.\n" },
    { "name": "vm.oom_kill", "doc": "## Name\nprobe::vm.oom_kill — \n     Fires when a thread is selected for termination by the OOM killer\n## Synopsis\n```\nvm.oom_kill \n```\n## Values\nname\n     name of the probe point\n    task\n     the task being killed\n## Context\nThe process that tried to consume excessive memory, and thus\n   triggered the OOM.\n" },
    { "name": "scheduler.balance", "doc": "## Name\nprobe::scheduler.balance — \n     A cpu attempting to find more work.\n## Synopsis\n```\nscheduler.balance \n```\n## Values\nname\n     name of the probe point\n## Context\nThe cpu looking for more work.\n" },
    { "name": "vm.kmem_cache_free", "doc": "## Name\nprobe::vm.kmem_cache_free — \n     Fires when kmem_cache_free is requested\n## Synopsis\n```\nvm.kmem_cache_free \n```\n## Values\nptr\n     Pointer to the kmemory allocated which is returned by kmem_cache\n    call_site\n     Address of the function calling this kmemory function\n    name\n     Name of the probe point\n    caller_function\n     Name of the caller function.\n" },
    { "name": "scheduler.cpu_off", "doc": "## Name\nprobe::scheduler.cpu_off — \n  Process is about to stop running on a cpu\n## Synopsis\n```\nscheduler.cpu_off \n```\n## Values\ntask_prev\n     the process leaving the cpu (same as current)\n    idle\n     boolean indicating whether current is the idle process\n    task_next\n     the process replacing current\n    name\n     name of the probe point\n## Context\nThe process leaving the cpu.\n" },
    { "name": "scheduler.cpu_on", "doc": "## Name\nprobe::scheduler.cpu_on — \n     Process is beginning execution on a cpu\n## Synopsis\n```\nscheduler.cpu_on \n```\n## Values\nidle\n     - boolean indicating whether current is the idle process\n    name\n     name of the probe point\n    task_prev\n     the process that was previously running on this cpu\n## Context\nThe resuming process.\n" },
    { "name": "scheduler.migrate", "doc": "## Name\nprobe::scheduler.migrate — \n     Task migrating across cpus\n## Synopsis\n```\nscheduler.migrate \n```\n## Values\npriority\n     priority of the task being migrated\n    name\n     name of the probe point\n    cpu_to\n     the destination cpu\n    pid\n     PID of the task being migrated\n    cpu_from\n     the original cpu\n    task\n     the process that is being migrated\n" },
    { "name": "scheduler.process_exit", "doc": "## Name\nprobe::scheduler.process_exit — \n     Process exiting\n## Synopsis\n```\nscheduler.process_exit \n```\n## Values\npid\n     PID of the process exiting\n    name\n     name of the probe point\n    priority\n     priority of the process exiting\n" },
    { "name": "scheduler.process_fork", "doc": "## Name\nprobe::scheduler.process_fork — \n     Process forked\n## Synopsis\n```\nscheduler.process_fork \n```\n## Values\nname\n     name of the probe point\n    parent_pid\n     PID of the parent process\n    child_pid\n     PID of the child process\n" },
    { "name": "scheduler.tick", "doc": "## Name\nprobe::scheduler.tick — \n     Schedulers internal tick, a processes timeslice accounting is updated\n## Synopsis\n```\nscheduler.tick \n```\n## Values\nname\n     name of the probe point\n    idle\n     boolean indicating whether current is the idle process\n## Context\nThe process whose accounting will be updated.\n" },
    { "name": "vm.pagefault", "doc": "## Name\nprobe::vm.pagefault — \n     Records that a page fault occurred\n## Synopsis\n```\nvm.pagefault \n```\n## Values\naddress\n     the address of the faulting memory access; i.e. the address that caused the page fault\n    name\n     name of the probe point\n    write_access\n     indicates whether this was a write or read access; 1 indicates a write, \n     while 0 indicates a read\n## Context\nThe process which triggered the fault\n" },
    { "name": "ioblock.request", "doc": "## Name\nprobe::ioblock.request — \n  Fires whenever making a generic block I/O request.\n## Synopsis\n```\nioblock.request \n```\n## Values\nphys_segments\n     number of segments in this bio after physical address coalescing is performed\n    rw\n     binary trace for read/write request\n    opf\n     operations and flags\n    flags\n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid \n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n    hw_segments\n     number of segments after physical and DMA remapping hardware coalescing is performed\n    bdev\n     target block device\n    size\n     total size in bytes\n    vcnt\n     bio vector count which represents number of array element (page, offset, length) which make up this I/O request\n    sector\n     beginning sector for the entire bio\n    bdev_contains\n     points to the device object which contains the partition (when bio structure represents a partition)\n    devname\n     block device name\n    p_start_sect\n     points to the start sector of the partition structure of the device\n    name\n     name of the probe point\n    idx\n     offset into the bio vector array\n    ino\n     i-node number of the mapped file\n## Context\nThe process makes block I/O request\n" },
    { "name": "ioblock.end", "doc": "## Name\nprobe::ioblock.end — \n     Fires whenever a block I/O transfer is complete.\n## Synopsis\n```\nioblock.end \n```\n## Values\nhw_segments\n     number of segments after physical and DMA remapping hardware coalescing is performed\n    vcnt\n     bio vector count which represents number of array element (page, offset, length) which makes up this I/O request\n    size\n     total size in bytes\n    phys_segments\n     number of segments in this bio after physical address coalescing is performed.\n    rw\n     binary trace for read/write request\n    flags\n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid\n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n    error\n     0 on success\n    opf\n     operations and flags\n    ino\n     i-node number of the mapped file\n    idx\n     offset into the bio vector array\n    bytes_done\n     number of bytes transferred\n    sector\n     beginning sector for the entire bio\n    name\n     name of the probe point\n    devname\n     block device name\n## Context\nThe process signals the transfer is done.\n" },
    { "name": "scheduler.process_free", "doc": "## Name\nprobe::scheduler.process_free — \n     Scheduler freeing a data structure for a process\n## Synopsis\n```\nscheduler.process_free \n```\n## Values\npriority\n     priority of the process getting freed\n    name\n     name of the probe point\n    pid\n     PID of the process getting freed\n" },
    { "name": "vm.kmem_cache_alloc", "doc": "## Name\nprobe::vm.kmem_cache_alloc — \n     Fires when kmem_cache_alloc is requested\n## Synopsis\n```\nvm.kmem_cache_alloc \n```\n## Values\nbytes_req\n     requested Bytes\n    gfp_flag_name\n     type of kmemory to allocate(in string format)\n    call_site\n     address of the function calling this kmemory function.\n    gfp_flags\n     type of kmemory to allocate\n    ptr\n     pointer to the kmemory allocated\n    bytes_alloc\n     allocated Bytes\n    caller_function\n     name of the caller function.\n    name\n     name of the probe point\n" },
    { "name": "ioscheduler.elv_add_request", "doc": "## Name\nprobe::ioscheduler.elv_add_request — \n     probe to indicate request is added to the request queue.\n## Synopsis\n```\nioscheduler.elv_add_request \n```\n## Values\nrq\n     Address of request.\n    elevator_name\n     The type of I/O elevator currently enabled.\n    q\n     Pointer to request queue.\n    disk_minor\n     Disk minor number of request.\n    rq_flags\n     Request flags.\n    disk_major\n     Disk major no of request.\n" },
    { "name": "scheduler.wakeup", "doc": "## Name\nprobe::scheduler.wakeup — \n     Task is woken up\n## Synopsis\n```\nscheduler.wakeup \n```\n## Values\nname\n     name of the probe point\n    task_tid\n     tid of the task being woken up\n    task_cpu\n     cpu of the task being woken up\n    task_pid\n     PID of the task being woken up\n    task_priority\n     priority of the task being woken up\n    task_state\n     state of the task being woken up\n" },
    { "name": "ioscheduler.elv_add_request.kp", "doc": "## Name\nprobe::ioscheduler.elv_add_request.kp — \n     kprobe based probe to indicate that a request was added to the request queue\n## Synopsis\n```\nioscheduler.elv_add_request.kp \n```\n## Values\nname\n     Name of the probe point\n    rq\n     Address of the request\n    elevator_name\n     The type of I/O elevator currently enabled\n    q\n     pointer to request queue\n    disk_minor\n     Disk minor number of the request\n    rq_flags\n     Request flags\n    disk_major\n     Disk major number of the request\n" },
    { "name": "scheduler.kthread_stop.return", "doc": "## Name\nprobe::scheduler.kthread_stop.return — \n     A kthread is stopped and gets the return value\n## Synopsis\n```\nscheduler.kthread_stop.return \n```\n## Values\nname\n     name of the probe point\n    return_value\n     return value after stopping the thread\n" },
    { "name": "ioblock_trace.request", "doc": "## Name\nprobe::ioblock_trace.request — \n     Fires just as a generic block I/O request is created for a bio.\n## Synopsis\n```\nioblock_trace.request \n```\n## Values\nbytes_done\n     number of bytes transferred\n    q\n     request queue on which this bio was queued.\n    idx\n     offset into the bio vector array\n     phys_segments - number of segments in this bio after physical address coalescing is performed.\n    ino\n     i-node number of the mapped file\n    name\n     name of the probe point\n    bdev_contains\n     points to the device object which contains the partition (when bio structure represents a partition)\n    p_start_sect\n     points to the start sector of the partition structure of the device\n    devname\n     block device name\n    sector\n     beginning sector for the entire bio\n    size\n     total size in bytes\n    vcnt\n     bio vector count which represents number of array element (page, offset, length) which make up this I/O request\n    bdev\n     target block device\n    flags\n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid\n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n    opf\n     operations and flags\n    rw\n     binary trace for read/write request\n## Context\nThe process makes block I/O request\n" },
    { "name": "ioscheduler.elv_add_request.tp", "doc": "## Name\nprobe::ioscheduler.elv_add_request.tp — \n     tracepoint based probe to indicate a request is added to the request queue.\n## Synopsis\n```\nioscheduler.elv_add_request.tp \n```\n## Values\nrq_flags\n     Request flags.\n    disk_minor\n     Disk minor number of request.\n    disk_major\n     Disk major no of request.\n    elevator_name\n     The type of I/O elevator currently enabled.\n    q\n     Pointer to request queue.\n    name\n     Name of the probe point\n    rq\n     Address of request.\n" },
    { "name": "ioscheduler.elv_next_request", "doc": "## Name\nprobe::ioscheduler.elv_next_request — \n  Fires when a request is retrieved from the request queue\n## Synopsis\n```\nioscheduler.elv_next_request \n```\n## Values\nelevator_name\n     The type of I/O elevator currently enabled\n    name\n     Name of the probe point\n" },
    { "name": "scheduler.signal_send", "doc": "## Name\nprobe::scheduler.signal_send — \n     Sending a signal\n## Synopsis\n```\nscheduler.signal_send \n```\n## Values\nname\n     name of the probe point\n    pid\n     pid of the process sending signal\n    signal_number\n     signal number\n" },
    { "name": "scheduler.process_wait", "doc": "## Name\nprobe::scheduler.process_wait — \n     Scheduler starting to wait on a process\n## Synopsis\n```\nscheduler.process_wait \n```\n## Values\nname\n     name of the probe point\n    pid\n     PID of the process scheduler is waiting on\n" },
    { "name": "ioscheduler.elv_next_request.return", "doc": "## Name\nprobe::ioscheduler.elv_next_request.return — \n     Fires when a request retrieval issues a return signal\n## Synopsis\n```\nioscheduler.elv_next_request.return \n```\n## Values\ndisk_major\n     Disk major number of the request\n    rq\n     Address of the request\n    name\n     Name of the probe point\n    disk_minor\n     Disk minor number of the request\n    rq_flags\n     Request flags\n" },
    { "name": "ioscheduler_trace.unplug_timer", "doc": "## Name\nprobe::ioscheduler_trace.unplug_timer — \n     Fires when unplug timer associated\n## Synopsis\n```\nioscheduler_trace.unplug_timer \n```\n## Values\nname\n     Name of the probe point\n    rq_queue\n     request queue\n## Description\nwith a request queue expires.\n" },
    { "name": "ioscheduler_trace.unplug_io", "doc": "## Name\nprobe::ioscheduler_trace.unplug_io — \n     Fires when a request queue is unplugged;\n## Synopsis\n```\nioscheduler_trace.unplug_io \n```\n## Values\nname\n     Name of the probe point\n    rq_queue\n     request queue\n## Description\nEither, when number of pending requests in the queue exceeds threshold\n   or, upon expiration of timer that was activated when queue was plugged.\n" },
    { "name": "vm.kmalloc_node", "doc": "## Name\nprobe::vm.kmalloc_node — \n     Fires when kmalloc_node is requested\n## Synopsis\n```\nvm.kmalloc_node \n```\n## Values\nbytes_req\n     requested Bytes\n    gfp_flag_name\n     type of kmemory to allocate(in string format)\n    call_site\n     address of the function caling this  kmemory function\n    gfp_flags\n     type of kmemory to allocate\n    ptr\n     pointer to the kmemory allocated\n    bytes_alloc\n     allocated Bytes\n    caller_function\n     name of the caller function\n    name\n     name of the probe point\n" },
    { "name": "scsi.iodispatching", "doc": "## Name\nprobe::scsi.iodispatching — \n     SCSI mid-layer dispatched low-level SCSI command\n## Synopsis\n```\nscsi.iodispatching \n```\n## Values\nchannel\n     The channel number\n    data_direction\n     The data_direction specifies whether this command is from/to the device\n     0 (DMA_BIDIRECTIONAL), 1 (DMA_TO_DEVICE),\n     2 (DMA_FROM_DEVICE), 3 (DMA_NONE)\n    device_state\n     The current state of the device\n    host_no\n     The host number\n    device_state_str\n     The current state of the device, as a string\n    lun\n     The lun number\n    req_addr\n     The current struct request pointer, as a number\n    dev_id\n     The scsi device id\n    request_bufflen\n     The request buffer length\n    request_buffer\n     The request buffer address\n    data_direction_str\n     Data direction, as a string\n" },
    { "name": "scsi.ioentry", "doc": "## Name\nprobe::scsi.ioentry — \n  Prepares a SCSI mid-layer request\n## Synopsis\n```\nscsi.ioentry \n```\n## Values\ndevice_state_str\n     The current state of the device, as a string\n    req_addr\n     The current struct request pointer, as a number\n    disk_minor\n     The minor number of the disk (-1 if no information)\n    disk_major\n     The major number of the disk (-1 if no information)\n    device_state\n     The current state of the device\n" },
    { "name": "scsi.set_state", "doc": "## Name\nprobe::scsi.set_state — \n     Order SCSI device state change\n## Synopsis\n```\nscsi.set_state \n```\n## Values\nhost_no\n     The host number\n    lun\n     The lun number\n    old_state_str\n     The current state of the device, as a string\n    dev_id\n     The scsi device id\n    channel\n     The channel number\n    old_state\n     The current state of the device\n    state_str\n     The new state of the device, as a string\n    state\n     The new state of the device\n" },
    { "name": "scheduler.kthread_stop", "doc": "## Name\nprobe::scheduler.kthread_stop — \n     A thread created by kthread_create is being stopped\n## Synopsis\n```\nscheduler.kthread_stop \n```\n## Values\nthread_priority\n     priority of the thread\n    thread_pid\n     PID of the thread being stopped\n" },
    { "name": "tty.open", "doc": "## Name\nprobe::tty.open — \n  Called when a tty is opened\n## Synopsis\n```\ntty.open \n```\n## Values\ninode_flags\n     the inode flags\n    file_flags\n     the file flags\n    file_name\n     the file name\n    inode_state\n     the inode state\n    file_mode\n     the file mode\n    inode_number\n     the inode number\n" },
    { "name": "scsi.iocompleted", "doc": "## Name\nprobe::scsi.iocompleted — \n     SCSI mid-layer running the completion processing for block device I/O requests\n## Synopsis\n```\nscsi.iocompleted \n```\n## Values\ndev_id\n     The scsi device id\n    data_direction_str\n     Data direction, as a string\n    device_state_str\n     The current state of the device, as a string\n    host_no\n     The host number\n    lun\n     The lun number\n    goodbytes\n     The bytes completed\n    req_addr\n     The current struct request pointer, as a number\n    device_state\n     The current state of the device\n    data_direction\n     The data_direction specifies whether this command is from/to\n     the device\n    channel\n     The channel number\n" },
    { "name": "tty.register", "doc": "## Name\nprobe::tty.register — \n     Called when a tty device is registred\n## Synopsis\n```\ntty.register \n```\n## Values\nindex\n     the tty index requested\n    name\n     the driver  .dev_name name\n    module\n     the module name\n    driver_name\n     the driver name\n" },
    { "name": "tty.release", "doc": "## Name\nprobe::tty.release — \n     Called when the tty is closed\n## Synopsis\n```\ntty.release \n```\n## Values\nfile_flags\n     the file flags\n    file_name\n     the file name\n    inode_state\n     the inode state\n    inode_flags\n     the inode flags\n    file_mode\n     the file mode\n    inode_number\n     the inode number\n" },
    { "name": "tty.init", "doc": "## Name\nprobe::tty.init — \n     Called when a tty is being initalized\n## Synopsis\n```\ntty.init \n```\n## Values\nname\n     the driver  .dev_name name\n    module\n     the module name\n    driver_name\n     the driver name\n" },
    { "name": "tty.unregister", "doc": "## Name\nprobe::tty.unregister — \n     Called when a tty device is being unregistered\n## Synopsis\n```\ntty.unregister \n```\n## Values\nindex\n     the tty index requested\n    module\n     the module name\n    name\n     the driver  .dev_name name\n    driver_name\n     the driver name\n" },
    { "name": "irq_handler.entry", "doc": "## Name\nprobe::irq_handler.entry — \n     Execution of interrupt handler starting\n## Synopsis\n```\nirq_handler.entry \n```\n## Values\naction\n     struct irqaction* for this interrupt num\n    thread\n     thread pointer for threaded interrupts\n    next_irqaction\n     pointer to next irqaction for shared interrupts\n    dev_id\n     Cookie to identify device\n    flags\n     Flags for IRQ handler\n    flags_str\n     symbolic string representation of IRQ flags\n    dir\n     pointer to the proc/irq/NN/name entry\n    handler\n     interrupt handler function\n    thread_flags\n     Flags related to thread\n    thread_fn\n     interrupt handler function for threaded interrupts\n    dev_name\n     name of device\n    irq\n     irq number\n" },
    { "name": "scheduler.wait_task", "doc": "## Name\nprobe::scheduler.wait_task — \n     Waiting on a task to unschedule (become inactive)\n## Synopsis\n```\nscheduler.wait_task \n```\n## Values\ntask_pid\n     PID of the task the scheduler is waiting on\n    task_priority\n     priority of the task\n    name\n     name of the probe point\n" },
    { "name": "irq_handler.exit", "doc": "## Name\nprobe::irq_handler.exit — \n     Execution of interrupt handler completed\n## Synopsis\n```\nirq_handler.exit \n```\n## Values\ndir\n     pointer to the proc/irq/NN/name entry\n    flags_str\n     symbolic string representation of IRQ flags\n    action\n     struct irqaction*\n    ret\n     return value of the handler\n    thread\n     thread pointer for threaded interrupts\n    dev_id\n     Cookie to identify device\n    next_irqaction\n     pointer to next irqaction for shared interrupts\n    flags\n     flags for IRQ handler\n    dev_name\n     name of device\n    irq\n     interrupt number\n    handler\n     interrupt handler function that was executed\n    thread_flags\n     Flags related to thread\n    thread_fn\n     interrupt handler function for threaded interrupts\n" },
    { "name": "tty.poll", "doc": "## Name\nprobe::tty.poll — \n     Called when a tty device is being polled\n## Synopsis\n```\ntty.poll \n```\n## Values\nfile_name\n     the tty file name\n    wait_key\n     the wait queue key\n" },
    { "name": "scheduler.wakeup_new", "doc": "## Name\nprobe::scheduler.wakeup_new — \n     Newly created task is woken up for the first time\n## Synopsis\n```\nscheduler.wakeup_new \n```\n## Values\ntask_tid\n     TID of the new task woken up\n    name\n     name of the probe point\n    task_state\n     state of the task woken up\n    task_priority\n     priority of the new task\n    task_pid\n     PID of the new task woken up\n    task_cpu\n     cpu of the task woken up\n" },
    { "name": "workqueue.create", "doc": "## Name\nprobe::workqueue.create — \n  Creating a new workqueue\n## Synopsis\n```\nworkqueue.create \n```\n## Values\ncpu\n     cpu for which the worker thread is created\n    wq_thread\n     task_struct of the workqueue thread\n" },
    { "name": "workqueue.destroy", "doc": "## Name\nprobe::workqueue.destroy — \n     Destroying workqueue\n## Synopsis\n```\nworkqueue.destroy \n```\n## Values\nwq_thread\n     task_struct of the workqueue thread\n" },
    { "name": "vm.kmem_cache_alloc_node", "doc": "## Name\nprobe::vm.kmem_cache_alloc_node — \n     Fires when kmem_cache_alloc_node is requested\n## Synopsis\n```\nvm.kmem_cache_alloc_node \n```\n## Values\nbytes_alloc\n     allocated Bytes\n    caller_function\n     name of the caller function\n    name\n     name of the probe point\n    gfp_flag_name\n     type of kmemory to allocate(in string format)\n    bytes_req\n     requested Bytes\n    call_site\n     address of the function calling this kmemory function\n    ptr\n     pointer to the kmemory allocated\n    gfp_flags\n     type of kmemory to allocate\n" },
    { "name": "ioscheduler_trace.plug", "doc": "## Name\nprobe::ioscheduler_trace.plug — \n     Fires when a request queue is plugged;\n## Synopsis\n```\nioscheduler_trace.plug \n```\n## Values\nrq_queue\n     request queue\n    name\n     Name of the probe point\n## Description\nie, requests in the queue cannot be serviced by block driver.\n" },
    { "name": "softirq.entry", "doc": "## Name\nprobe::softirq.entry — \n     Execution of handler for a pending softirq starting\n## Synopsis\n```\nsoftirq.entry \n```\n## Values\naction\n     pointer to softirq handler just about to execute\n    vec\n     softirq_action vector\n    vec_nr\n     softirq vector number\n    h\n     struct softirq_action* for current pending softirq\n" },
    { "name": "ioscheduler_trace.elv_requeue_request", "doc": "## Name\nprobe::ioscheduler_trace.elv_requeue_request — \n     Fires when a request is\n## Synopsis\n```\nioscheduler_trace.elv_requeue_request \n```\n## Values\ndisk_major\n     Disk major no of request.\n    disk_minor\n     Disk minor number of request.\n    rq_flags\n     Request flags.\n    name\n     Name of the probe point\n    rq\n     Address of request.\n    elevator_name\n     The type of I/O elevator currently enabled.\n## Description\nput back on the queue, when the hadware cannot accept more requests.\n" },
    { "name": "scsi.iodone", "doc": "## Name\nprobe::scsi.iodone — \n     SCSI command completed by low level driver and enqueued into the done queue.\n## Synopsis\n```\nscsi.iodone \n```\n## Values\ndata_direction\n     The data_direction specifies whether this command is\n     from/to the device.\n    channel\n     The channel number\n    device_state\n     The current state of the device\n    req_addr\n     The current struct request pointer, as a number\n    lun\n     The lun number\n    device_state_str\n     The current state of the device, as a string\n    scsi_timer_pending\n     1 if a timer is pending on this request\n    host_no\n     The host number\n    data_direction_str\n     Data direction, as a string\n    dev_id\n     The scsi device id\n" },
    { "name": "workqueue.insert", "doc": "## Name\nprobe::workqueue.insert — \n     Queuing work on a workqueue\n## Synopsis\n```\nworkqueue.insert \n```\n## Values\nwork_func\n     pointer to handler function\n    wq_thread\n     task_struct of the workqueue thread\n    work\n     work_struct* being queued\n" },
    { "name": "ioscheduler.elv_completed_request", "doc": "## Name\nprobe::ioscheduler.elv_completed_request — \n     Fires when a request is completed\n## Synopsis\n```\nioscheduler.elv_completed_request \n```\n## Values\nname\n     Name of the probe point\n    rq\n     Address of the request\n    elevator_name\n     The type of I/O elevator currently enabled\n    rq_flags\n     Request flags\n    disk_minor\n     Disk minor number of the request\n    disk_major\n     Disk major number of the request\n" },
    { "name": "netdev.change_mac", "doc": "## Name\nprobe::netdev.change_mac — \n     Called when the netdev_name has the MAC changed\n## Synopsis\n```\nnetdev.change_mac \n```\n## Values\ndev_name\n     The device that will have the MAC changed\n    new_mac\n     The new MAC address\n    old_mac\n     The current MAC address\n    mac_len\n     The MAC length\n" },
    { "name": "netdev.change_rx_flag", "doc": "## Name\nprobe::netdev.change_rx_flag — \n     Called when the device RX flag will be changed\n## Synopsis\n```\nnetdev.change_rx_flag \n```\n## Values\ndev_name\n     The device that will be changed\n    flags\n     The new flags\n" },
    { "name": "netdev.close", "doc": "## Name\nprobe::netdev.close — \n     Called when the device is closed\n## Synopsis\n```\nnetdev.close \n```\n## Values\ndev_name\n     The device that is going to be closed\n" },
    { "name": "netdev.ioctl", "doc": "## Name\nprobe::netdev.ioctl — \n     Called when the device suffers an IOCTL\n## Synopsis\n```\nnetdev.ioctl \n```\n## Values\ncmd\n     The IOCTL request\n    arg\n     The IOCTL argument (usually the netdev interface)\n" },
    { "name": "netdev.open", "doc": "## Name\nprobe::netdev.open — \n     Called when the device is opened\n## Synopsis\n```\nnetdev.open \n```\n## Values\ndev_name\n     The device that is going to be opened\n" },
    { "name": "tty.resize", "doc": "## Name\nprobe::tty.resize — \n     Called when a terminal resize happens\n## Synopsis\n```\ntty.resize \n```\n## Values\nnew_xpixel\n     the new xpixel value\n    old_xpixel\n     the old xpixel\n    new_row\n     the new row value\n    name\n     the tty name\n    new_col\n     the new col value\n    old_ypixel\n     the old ypixel\n    old_col\n     the old col value\n    new_ypixel\n     the new ypixel value\n    old_row\n     the old row value\n" },
    { "name": "netdev.rx", "doc": "## Name\nprobe::netdev.rx — \n     Called when the device is going to receive a packet\n## Synopsis\n```\nnetdev.rx \n```\n## Values\nprotocol\n     The packet protocol\n    dev_name\n     The device received the packet\n" },
    { "name": "netdev.register", "doc": "## Name\nprobe::netdev.register — \n     Called when the device is registered\n## Synopsis\n```\nnetdev.register \n```\n## Values\ndev_name\n     The device that is going to be registered\n" },
    { "name": "netfilter.arp.forward", "doc": "## Name\nprobe::netfilter.arp.forward — \n     - Called for each ARP packet to be forwarded\n## Synopsis\n```\nnetfilter.arp.forward \n```\n## Values\nnf_accept\n     Constant used to signify an 'accept' verdict\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    ar_tip\n     Ethernet+IP only (ar_pro==0x800): target IP address\n    ar_hrd\n     Format of hardware address\n    indev\n     Address of net_device representing input device, 0 if unknown\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    arphdr\n     Address of ARP header\n    ar_data\n     Address of ARP packet data region (after the header)\n    ar_pro\n     Format of protocol address\n    pf\n     Protocol family -- always “arp”\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    ar_tha\n     Ethernet+IP only (ar_pro==0x800): target hardware (MAC) address\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    ar_sha\n     Ethernet+IP only (ar_pro==0x800): source hardware (MAC) address \n    data_str\n     A string representing the packet buffer contents\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    ar_hln\n     Length of hardware address\n    length\n     The length of the packet buffer contents, in bytes\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    ar_pln\n     Length of protocol address\n    indev_name\n     Name of network device packet was received on (if known)\n    ar_op\n     ARP opcode (command)\n    ar_sip\n     Ethernet+IP only (ar_pro==0x800): source IP address\n" },
    { "name": "netfilter.arp.in", "doc": "## Name\nprobe::netfilter.arp.in — \n     - Called for each incoming ARP packet\n## Synopsis\n```\nnetfilter.arp.in \n```\n## Values\ndata_hex\n     A hexadecimal string representing the packet buffer contents\n    ar_tha\n     Ethernet+IP only (ar_pro==0x800): target hardware (MAC) address\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    arphdr\n     Address of ARP header\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    pf\n     Protocol family -- always “arp”\n    ar_pro\n     Format of protocol address\n    ar_data\n     Address of ARP packet data region (after the header)\n    indev\n     Address of net_device representing input device, 0 if unknown\n    ar_tip\n     Ethernet+IP only (ar_pro==0x800): target IP address\n    ar_hrd\n     Format of hardware address\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    ar_op\n     ARP opcode (command)\n    indev_name\n     Name of network device packet was received on (if known)\n    ar_sip\n     Ethernet+IP only (ar_pro==0x800): source IP address\n    ar_pln\n     Length of protocol address\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    length\n     The length of the packet buffer contents, in bytes\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    ar_hln\n     Length of hardware address\n    data_str\n     A string representing the packet buffer contents\n    ar_sha\n     Ethernet+IP only (ar_pro==0x800): source hardware (MAC) address\n" },
    { "name": "softirq.exit", "doc": "## Name\nprobe::softirq.exit — \n     Execution of handler for a pending softirq completed\n## Synopsis\n```\nsoftirq.exit \n```\n## Values\nh\n     struct softirq_action* for just executed softirq\n    vec_nr\n     softirq vector number\n    vec\n     softirq_action vector\n    action\n     pointer to softirq handler that just finished execution\n" },
    { "name": "netfilter.arp.out", "doc": "## Name\nprobe::netfilter.arp.out — \n     - Called for each outgoing ARP packet\n## Synopsis\n```\nnetfilter.arp.out \n```\n## Values\ndata_hex\n     A hexadecimal string representing the packet buffer contents\n    ar_tha\n     Ethernet+IP only (ar_pro==0x800): target hardware (MAC) address\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    arphdr\n     Address of ARP header\n    ar_data\n     Address of ARP packet data region (after the header)\n    ar_pro\n     Format of protocol address\n    pf\n     Protocol family -- always “arp”\n    indev\n     Address of net_device representing input device, 0 if unknown\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    ar_tip\n     Ethernet+IP only (ar_pro==0x800): target IP address\n    ar_hrd\n     Format of hardware address\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    indev_name\n     Name of network device packet was received on (if known)\n    ar_op\n     ARP opcode (command)\n    ar_sip\n     Ethernet+IP only (ar_pro==0x800): source IP address\n    ar_pln\n     Length of protocol address\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    ar_hln\n     Length of hardware address\n    length\n     The length of the packet buffer contents, in bytes\n    data_str\n     A string representing the packet buffer contents\n    ar_sha\n     Ethernet+IP only (ar_pro==0x800): source hardware (MAC) address\n" },
    { "name": "netdev.change_mtu", "doc": "## Name\nprobe::netdev.change_mtu — \n     Called when the netdev MTU is changed\n## Synopsis\n```\nnetdev.change_mtu \n```\n## Values\ndev_name\n     The device that will have the MTU changed\n    new_mtu\n     The new MTU\n    old_mtu\n     The current MTU\n" },
    { "name": "netfilter.bridge.forward", "doc": "## Name\nprobe::netfilter.bridge.forward — \n     Called on an incoming bridging packet destined for some other computer\n## Synopsis\n```\nnetfilter.bridge.forward \n```\n## Values\nbr_type\n     BPDU type\n    br_mac\n     Bridge MAC address\n    br_prid\n     Protocol identifier\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    llcpdu\n     Address of LLC Protocol Data Unit\n    br_poid\n     Port identifier\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    pf\n     Protocol family -- always “bridge”\n    indev\n     Address of net_device representing input device, 0 if unknown\n    br_msg\n     Message age in 1/256 secs\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    brhdr\n     Address of bridge header\n    br_vid\n     Protocol version identifier\n    br_flags\n     BPDU flags\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    br_fd\n     Forward delay in 1/256 secs\n    br_rmac\n     Root bridge MAC address\n    llcproto_stp\n     Constant used to signify Bridge Spanning Tree Protocol packet\n    br_max\n     Max age in 1/256 secs\n    br_rid\n     Identity of root bridge\n    length\n     The length of the packet buffer contents, in bytes\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    protocol\n     Packet protocol\n    data_str\n     A string representing the packet buffer contents\n    br_bid\n     Identity of bridge\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    indev_name\n     Name of network device packet was received on (if known)\n    br_htime\n     Hello time in 1/256 secs\n    br_cost\n     Total cost from transmitting bridge to root\n" },
    { "name": "scsi.ioexecute", "doc": "## Name\nprobe::scsi.ioexecute — \n     Create mid-layer SCSI request and wait for the result\n## Synopsis\n```\nscsi.ioexecute \n```\n## Values\nretries\n     Number of times to retry request\n    timeout\n     Request timeout in seconds\n    data_direction\n     The data_direction specifies whether this command is\n     from/to the device.\n    channel\n     The channel number\n    device_state\n     The current state of the device\n    lun\n     The lun number\n    device_state_str\n     The current state of the device, as a string\n    host_no\n     The host number\n    request_bufflen\n     The data buffer buffer length\n    request_buffer\n     The data buffer address\n    dev_id\n     The scsi device id\n    data_direction_str\n     Data direction, as a string\n" },
    { "name": "netfilter.bridge.post_routing", "doc": "## Name\nprobe::netfilter.bridge.post_routing — \n     - Called before a bridging packet hits the wire\n## Synopsis\n```\nnetfilter.bridge.post_routing \n```\n## Values\nindev_name\n     Name of network device packet was received on (if known)\n    br_htime\n     Hello time in 1/256 secs\n    br_cost\n     Total cost from transmitting bridge to root\n    length\n     The length of the packet buffer contents, in bytes\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    protocol\n     Packet protocol\n    data_str\n     A string representing the packet buffer contents\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    br_bid\n     Identity of bridge\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    brhdr\n     Address of bridge header\n    br_vid\n     Protocol version identifier\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    br_flags\n     BPDU flags\n    br_fd\n     Forward delay in 1/256 secs\n    br_rmac\n     Root bridge MAC address\n    llcproto_stp\n     Constant used to signify Bridge Spanning Tree Protocol packet\n    br_max\n     Max age in 1/256 secs\n    br_rid\n     Identity of root bridge\n    br_type\n     BPDU type\n    br_mac\n     Bridge MAC address\n    br_prid\n     Protocol identifier\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    llcpdu\n     Address of LLC Protocol Data Unit\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    br_poid\n     Port identifier\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    pf\n     Protocol family -- always “bridge”\n    indev\n     Address of net_device representing input device, 0 if unknown\n    br_msg\n     Message age in 1/256 secs\n" },
    { "name": "netfilter.bridge.pre_routing", "doc": "## Name\nprobe::netfilter.bridge.pre_routing — \n     - Called before a bridging packet is routed\n## Synopsis\n```\nnetfilter.bridge.pre_routing \n```\n## Values\noutdev\n     Address of net_device representing output device, 0 if unknown\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    br_fd\n     Forward delay in 1/256 secs\n    br_rmac\n     Root bridge MAC address\n    llcproto_stp\n     Constant used to signify Bridge Spanning Tree Protocol packet\n    br_max\n     Max age in 1/256 secs\n    br_rid\n     Identity of root bridge\n    brhdr\n     Address of bridge header\n    br_vid\n     Protocol version identifier\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    br_flags\n     BPDU flags\n    llcpdu\n     Address of LLC Protocol Data Unit\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    br_type\n     BPDU type\n    br_mac\n     Bridge MAC address\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    br_prid\n     Protocol identifier\n    indev\n     Address of net_device representing input device, 0 if unknown\n    br_msg\n     Message age in 1/256 secs\n    br_poid\n     Port identifier\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    pf\n     Protocol family -- always “bridge”\n    br_htime\n     Hello time in 1/256 secs\n    br_cost\n     Total cost from transmitting bridge to root\n    indev_name\n     Name of network device packet was received on (if known)\n    data_str\n     A string representing the packet buffer contents\n    length\n     The length of the packet buffer contents, in bytes\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    protocol\n     Packet protocol\n    br_bid\n     Identity of bridge\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n" },
    { "name": "netfilter.ip.forward", "doc": "## Name\nprobe::netfilter.ip.forward — \n     Called on an incoming IP packet addressed to some other computer\n## Synopsis\n```\nnetfilter.ip.forward \n```\n## Values\noutdev\n     Address of net_device representing output device, 0 if unknown\n    family\n     IP address family\n    ipproto_tcp\n     Constant used to signify that the packet protocol is TCP\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    saddr\n     A string representing the source IP address\n    iphdr\n     Address of IP header\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    dport\n     TCP or UDP destination port (ipv4 only)\n    syn\n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    ipproto_udp\n     Constant used to signify that the packet protocol is UDP\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    indev\n     Address of net_device representing input device, 0 if unknown\n    ack\n     TCP ACK flag (if protocol is TCP; ipv4 only)\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    pf\n     Protocol family -- either “ipv4” or “ipv6”\n    psh\n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    indev_name\n     Name of network device packet was received on (if known)\n    rst\n     TCP RST flag (if protocol is TCP; ipv4 only)\n    data_str\n     A string representing the packet buffer contents\n    sport\n     TCP or UDP source port (ipv4 only)\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    daddr\n     A string representing the destination IP address\n    length\n     The length of the packet buffer contents, in bytes\n    protocol\n     Packet protocol from driver (ipv4 only)\n    urg\n     TCP URG flag (if protocol is TCP; ipv4 only)\n    fin\n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n" },
    { "name": "netfilter.ip.local_in", "doc": "## Name\nprobe::netfilter.ip.local_in — \n     Called on an incoming IP packet addressed to the local computer\n## Synopsis\n```\nnetfilter.ip.local_in \n```\n## Values\noutdev\n     Address of net_device representing output device, 0 if unknown\n    ipproto_tcp\n     Constant used to signify that the packet protocol is TCP\n    family\n     IP address family\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    saddr\n     A string representing the source IP address\n    iphdr\n     Address of IP header\n    dport\n     TCP or UDP destination port (ipv4 only)\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    syn\n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    ipproto_udp\n     Constant used to signify that the packet protocol is UDP\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    indev\n     Address of net_device representing input device, 0 if unknown\n    ack\n     TCP ACK flag (if protocol is TCP; ipv4 only)\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    pf\n     Protocol family -- either “ipv4” or “ipv6”\n    psh\n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    rst\n     TCP RST flag (if protocol is TCP; ipv4 only)\n    indev_name\n     Name of network device packet was received on (if known)\n    sport\n     TCP or UDP source port (ipv4 only)\n    data_str\n     A string representing the packet buffer contents\n    daddr\n     A string representing the destination IP address\n    length\n     The length of the packet buffer contents, in bytes\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    protocol\n     Packet protocol from driver (ipv4 only)\n    urg\n     TCP URG flag (if protocol is TCP; ipv4 only)\n    fin\n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n" },
    { "name": "tty.ioctl", "doc": "## Name\nprobe::tty.ioctl — \n     called when a ioctl is request to the tty\n## Synopsis\n```\ntty.ioctl \n```\n## Values\ncmd\n     the ioctl command\n    arg\n     the ioctl argument\n    name\n     the file name\n" },
    { "name": "netfilter.ip.pre_routing", "doc": "## Name\nprobe::netfilter.ip.pre_routing — \n  Called before an IP packet is routed\n## Synopsis\n```\nnetfilter.ip.pre_routing \n```\n## Values\nurg\n     TCP URG flag (if protocol is TCP; ipv4 only)\n    fin\n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    data_str\n     A string representing the packet buffer contents\n    sport\n     TCP or UDP source port (ipv4 only)\n    protocol\n     Packet protocol from driver (ipv4 only)\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    length\n     The length of the packet buffer contents, in bytes\n    daddr\n     A string representing the destination IP address\n    psh\n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    indev_name\n     Name of network device packet was received on (if known)\n    rst\n     TCP RST flag (if protocol is TCP; ipv4 only)\n    ack\n     TCP ACK flag (if protocol is TCP; ipv4 only)\n    indev\n     Address of net_device representing input device, 0 if unknown\n    pf\n     Protocol family - either 'ipv4' or 'ipv6'\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    ipproto_udp\n     Constant used to signify that the packet protocol is UDP\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    syn\n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    saddr\n     A string representing the source IP address\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    dport\n     TCP or UDP destination port (ipv4 only)\n    iphdr\n     Address of IP header\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    family\n     IP address family\n    ipproto_tcp\n     Constant used to signify that the packet protocol is TCP\n" },
    { "name": "sunrpc.clnt.call_sync", "doc": "## Name\nprobe::sunrpc.clnt.call_sync — \n     Make a synchronous RPC call\n## Synopsis\n```\nsunrpc.clnt.call_sync \n```\n## Values\nvers\n     the RPC program version number\n    progname\n     the RPC program name\n    prot\n     the IP protocol number\n    dead\n     whether this client is abandoned\n    prog\n     the RPC program number\n    port\n     the port number\n    proc\n     the procedure number in this RPC call\n    procname\n     the procedure name in this RPC call\n    flags\n     flags\n    servername\n     the server machine name\n    xid\n     current transmission id\n" },
    { "name": "sunrpc.clnt.clone_client", "doc": "## Name\nprobe::sunrpc.clnt.clone_client — \n     Clone an RPC client structure\n## Synopsis\n```\nsunrpc.clnt.clone_client \n```\n## Values\nvers\n     the RPC program version number\n    authflavor\n     the authentication flavor\n    progname\n     the RPC program name\n    prot\n     the IP protocol number\n    servername\n     the server machine name\n    prog\n     the RPC program number\n    port\n     the port number\n" },
    { "name": "sunrpc.clnt.call_async", "doc": "## Name\nprobe::sunrpc.clnt.call_async — \n     Make an asynchronous RPC call\n## Synopsis\n```\nsunrpc.clnt.call_async \n```\n## Values\nproc\n     the procedure number in this RPC call\n    port\n     the port number\n    procname\n     the procedure name in this RPC call\n    flags\n     flags\n    xid\n     current transmission id\n    servername\n     the server machine name\n    progname\n     the RPC program name\n    prot\n     the IP protocol number\n    dead\n     whether this client is abandoned\n    vers\n     the RPC program version number\n    prog\n     the RPC program number\n" },
    { "name": "sunrpc.clnt.restart_call", "doc": "## Name\nprobe::sunrpc.clnt.restart_call — \n     Restart an asynchronous RPC call\n## Synopsis\n```\nsunrpc.clnt.restart_call \n```\n## Values\nprog\n     the RPC program number\n    tk_pid\n     the debugging aid of task\n    tk_runstate\n     the task run status\n    tk_flags\n     the task flags\n    tk_priority\n     the task priority\n    xid\n     the transmission id\n    servername\n     the server machine name\n" },
    { "name": "sunrpc.sched.execute", "doc": "## Name\nprobe::sunrpc.sched.execute — \n     Execute the RPC `scheduler'\n## Synopsis\n```\nsunrpc.sched.execute \n```\n## Values\nprot\n     the IP protocol in the RPC call\n    vers\n     the program version in the RPC call\n    tk_pid\n     the debugging id of the task\n    tk_flags\n     the flags of the task\n    prog\n     the program number in the RPC call\n    xid\n     the transmission id in the RPC call\n" },
    { "name": "sunrpc.sched.delay", "doc": "## Name\nprobe::sunrpc.sched.delay — \n     Delay an RPC task\n## Synopsis\n```\nsunrpc.sched.delay \n```\n## Values\nprog\n     the program number in the RPC call\n    vers\n     the program version in the RPC call\n    tk_flags\n     the flags of the task\n    tk_pid\n     the debugging id of the task\n    prot\n     the IP protocol in the RPC call\n    xid\n     the transmission id in the RPC call\n    delay\n     the time delayed\n" },
    { "name": "sunrpc.sched.new_task", "doc": "## Name\nprobe::sunrpc.sched.new_task — \n     Create new task for the specified client\n## Synopsis\n```\nsunrpc.sched.new_task \n```\n## Values\ntk_flags\n     the flags of the task\n    vers\n     the program version in the RPC call\n    prot\n     the IP protocol in the RPC call\n    prog\n     the program number in the RPC call\n    xid\n     the transmission id in the RPC call\n" },
    { "name": "netdev.transmit", "doc": "## Name\nprobe::netdev.transmit — \n     Network device transmitting buffer\n## Synopsis\n```\nnetdev.transmit \n```\n## Values\nprotocol\n     The protocol of this packet(defined in include/linux/if_ether.h).\n    dev_name\n     The name of the device. e.g: eth0, ath1.\n    truesize\n     The size of the data to be transmitted.\n    length\n     The length of the transmit buffer.\n" },
    { "name": "sunrpc.svc.create", "doc": "## Name\nprobe::sunrpc.svc.create — \n     Create an RPC service\n## Synopsis\n```\nsunrpc.svc.create \n```\n## Values\npg_nvers\n     the number of supported versions\n    progname\n     the name of the program\n    prog\n     the number of the program\n    bufsize\n     the buffer size\n" },
    { "name": "sunrpc.clnt.create_client", "doc": "## Name\nprobe::sunrpc.clnt.create_client — \n  Create an RPC client\n## Synopsis\n```\nsunrpc.clnt.create_client \n```\n## Values\nport\n     the port number\n    servername\n     the server machine name\n    prog\n     the RPC program number\n    vers\n     the RPC program version number\n    prot\n     the IP protocol number\n    progname\n     the RPC program name\n    authflavor\n     the authentication flavor\n" },
    { "name": "netdev.set_promiscuity", "doc": "## Name\nprobe::netdev.set_promiscuity — \n     Called when the device enters/leaves promiscuity\n## Synopsis\n```\nnetdev.set_promiscuity \n```\n## Values\ndev_name\n     The device that is entering/leaving promiscuity mode\n    disable\n     If the device is leaving promiscuity mode\n    inc\n     Count the number of promiscuity openers\n    enable\n     If the device is entering promiscuity mode\n" },
    { "name": "netdev.unregister", "doc": "## Name\nprobe::netdev.unregister — \n     Called when the device is being unregistered\n## Synopsis\n```\nnetdev.unregister \n```\n## Values\ndev_name\n     The device that is going to be unregistered\n" },
    { "name": "sunrpc.svc.recv", "doc": "## Name\nprobe::sunrpc.svc.recv — \n     Listen for the next RPC request on any socket\n## Synopsis\n```\nsunrpc.svc.recv \n```\n## Values\nsv_nrthreads\n     the number of concurrent threads\n    sv_name\n     the service name\n    timeout\n     the timeout of waiting for data\n    sv_prog\n     the number of the program\n" },
    { "name": "sunrpc.svc.send", "doc": "## Name\nprobe::sunrpc.svc.send — \n     Return reply to RPC client\n## Synopsis\n```\nsunrpc.svc.send \n```\n## Values\nrq_proc\n     the procedure number in the request\n    rq_xid\n     the transmission id in the request\n    rq_prog\n     the program number in the request\n    rq_prot\n     the IP protocol of the reqeust\n    rq_vers\n     the program version in the request\n    sv_name\n     the service name\n    peer_ip\n     the peer address where the request is from\n" },
    { "name": "sunrpc.svc.drop", "doc": "## Name\nprobe::sunrpc.svc.drop — \n     Drop RPC request\n## Synopsis\n```\nsunrpc.svc.drop \n```\n## Values\nrq_vers\n     the program version in the request\n    rq_prot\n     the IP protocol of the reqeust\n    rq_prog\n     the program number in the request\n    rq_xid\n     the transmission id in the request\n    rq_proc\n     the procedure number in the request\n    peer_ip\n     the peer address where the request is from\n    sv_name\n     the service name\n" },
    { "name": "netfilter.bridge.local_out", "doc": "## Name\nprobe::netfilter.bridge.local_out — \n     Called on a bridging packet coming from a local process\n## Synopsis\n```\nnetfilter.bridge.local_out \n```\n## Values\nbr_bid\n     Identity of bridge\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    protocol\n     Packet protocol\n    length\n     The length of the packet buffer contents, in bytes\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    data_str\n     A string representing the packet buffer contents\n    indev_name\n     Name of network device packet was received on (if known)\n    br_htime\n     Hello time in 1/256 secs\n    br_cost\n     Total cost from transmitting bridge to root\n    pf\n     Protocol family -- always “bridge”\n    br_poid\n     Port identifier\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    indev\n     Address of net_device representing input device, 0 if unknown\n    br_msg\n     Message age in 1/256 secs\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    br_prid\n     Protocol identifier\n    br_type\n     BPDU type\n    br_mac\n     Bridge MAC address\n    llcpdu\n     Address of LLC Protocol Data Unit\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    br_vid\n     Protocol version identifier\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    br_flags\n     BPDU flags\n    brhdr\n     Address of bridge header\n    llcproto_stp\n     Constant used to signify Bridge Spanning Tree Protocol packet\n    br_rid\n     Identity of root bridge\n    br_max\n     Max age in 1/256 secs\n    br_fd\n     Forward delay in 1/256 secs\n    br_rmac\n     Root bridge MAC address\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    outdev\n     Address of net_device representing output device, 0 if unknown\n" },
    { "name": "tcp.disconnect", "doc": "## Name\nprobe::tcp.disconnect — \n     TCP socket disconnection\n## Synopsis\n```\ntcp.disconnect \n```\n## Values\nname\n     Name of this probe\n    family\n     IP address family\n    saddr\n     A string representing the source IP address\n    daddr\n     A string representing the destination IP address\n    flags\n     TCP flags (e.g. FIN, etc)  \n    dport\n     TCP destination port\n    sock\n     Network socket \n    sport\n     TCP source port\n## Context\nThe process which disconnects tcp\n" },
    { "name": "tcp.disconnect.return", "doc": "## Name\nprobe::tcp.disconnect.return — \n     TCP socket disconnection complete\n## Synopsis\n```\ntcp.disconnect.return \n```\n## Values\nret\n     Error code (0: no error) \n    name\n     Name of this probe\n## Context\nThe process which disconnects tcp\n" },
    { "name": "tcp.receive", "doc": "## Name\nprobe::tcp.receive — \n     Called when a TCP packet is received\n## Synopsis\n```\ntcp.receive \n```\n## Values\npsh\n     TCP PSH flag\n    urg\n     TCP URG flag\n    iphdr\n     IP header address\n    syn\n     TCP SYN flag\n    daddr\n     A string representing the destination IP address\n    rst\n     TCP RST flag\n    sport\n     TCP source port\n    name\n     Name of the probe point\n    ack\n     TCP ACK flag\n    family\n     IP address family\n    saddr\n     A string representing the source IP address\n    fin\n     TCP FIN flag\n    protocol\n     Packet protocol from driver\n    dport\n     TCP destination port\n" },
    { "name": "netdev.hard_transmit", "doc": "## Name\nprobe::netdev.hard_transmit — \n     Called when the devices is going to TX (hard)\n## Synopsis\n```\nnetdev.hard_transmit \n```\n## Values\ndev_name\n     The device scheduled to transmit\n    protocol\n     The protocol used in the transmission\n    truesize\n     The size of the data to be transmitted.\n    length\n     The length of the transmit buffer.\n" },
    { "name": "tcp.sendmsg", "doc": "## Name\nprobe::tcp.sendmsg — \n  Sending a tcp message\n## Synopsis\n```\ntcp.sendmsg \n```\n## Values\nname\n     Name of this probe\n    family\n     IP address family\n    sock\n     Network socket \n    size\n     Number of bytes to send\n## Context\nThe process which sends a tcp message\n" },
    { "name": "tcp.recvmsg.return", "doc": "## Name\nprobe::tcp.recvmsg.return — \n     Receiving TCP message complete\n## Synopsis\n```\ntcp.recvmsg.return \n```\n## Values\nsaddr\n     A string representing the source IP address\n    daddr\n     A string representing the destination IP address\n    dport\n     TCP destination port\n    size\n     Number of bytes received or error code if an error occurred.\n    sport\n     TCP source port \n    name\n     Name of this probe\n    family\n     IP address family\n## Context\nThe process which receives a tcp message\n" },
    { "name": "tcp.sendmsg.return", "doc": "## Name\nprobe::tcp.sendmsg.return — \n     Sending TCP message is done\n## Synopsis\n```\ntcp.sendmsg.return \n```\n## Values\nsize\n     Number of bytes sent or error code if an error occurred. \n    name\n     Name of this probe\n## Context\nThe process which sends a tcp message\n" },
    { "name": "tcp.setsockopt", "doc": "## Name\nprobe::tcp.setsockopt — \n     Call to setsockopt\n## Synopsis\n```\ntcp.setsockopt \n```\n## Values\nfamily\n     IP address family\n    level\n     The level at which the socket options will be manipulated\n    optname\n     TCP socket options (e.g. TCP_NODELAY, TCP_MAXSEG, etc)\n    name\n     Name of this probe\n    optlen\n     Used to access values for setsockopt\n    optstr\n     Resolves optname to a human-readable format\n    sock\n     Network socket\n## Context\nThe process which calls setsockopt\n" },
    { "name": "udp.disconnect.return", "doc": "## Name\nprobe::udp.disconnect.return — \n     UDP has been disconnected successfully\n## Synopsis\n```\nudp.disconnect.return \n```\n## Values\nsport\n     UDP source port\n    name\n     The name of this probe\n    daddr\n     A string representing the destination IP address\n    dport\n     UDP destination port\n    family\n     IP address family\n    saddr\n     A string representing the source IP address\n    ret\n     Error code (0: no error)\n## Context\nThe process which requested a UDP disconnection\n" },
    { "name": "ioscheduler_trace.elv_issue_request", "doc": "## Name\nprobe::ioscheduler_trace.elv_issue_request — \n     Fires when a request is\n## Synopsis\n```\nioscheduler_trace.elv_issue_request \n```\n## Values\ndisk_major\n     Disk major no of request.\n    rq_flags\n     Request flags.\n    disk_minor\n     Disk minor number of request.\n    elevator_name\n     The type of I/O elevator currently enabled.\n    rq\n     Address of request.\n    name\n     Name of the probe point\n## Description\nscheduled.\n" },
    { "name": "udp.recvmsg", "doc": "## Name\nprobe::udp.recvmsg — \n     Fires whenever a UDP message is received\n## Synopsis\n```\nudp.recvmsg \n```\n## Values\ndaddr\n     A string representing the destination IP address\n    sport\n     UDP source port\n    sock\n     Network socket used by the process\n    name\n     The name of this probe\n    family\n     IP address family\n    saddr\n     A string representing the source IP address\n    size\n     Number of bytes received by the process\n    dport\n     UDP destination port\n## Context\nThe process which received a UDP message\n" },
    { "name": "udp.recvmsg.return", "doc": "## Name\nprobe::udp.recvmsg.return — \n     Fires whenever an attempt to receive a UDP message received is completed\n## Synopsis\n```\nudp.recvmsg.return \n```\n## Values\nname\n     The name of this probe\n    sport\n     UDP source port\n    daddr\n     A string representing the destination IP address\n    dport\n     UDP destination port\n    size\n     Number of bytes received by the process\n    saddr\n     A string representing the source IP address\n    family\n     IP address family\n## Context\nThe process which received a UDP message\n" },
    { "name": "udp.sendmsg", "doc": "## Name\nprobe::udp.sendmsg — \n  Fires whenever a process sends a UDP message\n## Synopsis\n```\nudp.sendmsg \n```\n## Values\nsock\n     Network socket used by the process \n    name\n     The name of this probe\n    sport\n     UDP source port\n    daddr\n     A string representing the destination IP address\n    size\n     Number of bytes sent by the process\n    dport\n     UDP destination port\n    saddr\n     A string representing the source IP address\n    family\n     IP address family\n## Context\nThe process which sent a UDP message\n" },
    { "name": "ioblock_trace.bounce", "doc": "## Name\nprobe::ioblock_trace.bounce — \n     Fires whenever a buffer bounce is needed for at least one page of a block IO request.\n## Synopsis\n```\nioblock_trace.bounce \n```\n## Values\nino\n     i-node number of the mapped file\n    idx\n     offset into the bio vector array\n     phys_segments - number of segments in this bio after physical address coalescing is performed.\n    q\n     request queue on which this bio was queued.\n    bytes_done\n     number of bytes transferred\n    sector\n     beginning sector for the entire bio\n    devname\n     device for which a buffer bounce was needed.\n    p_start_sect\n     points to the start sector of the partition structure of the device\n    bdev_contains\n     points to the device object which contains the partition (when bio structure represents a partition)\n    name\n     name of the probe point\n    bdev\n     target block device\n    vcnt\n     bio vector count which represents number of array element (page, offset, length) which makes up this I/O request\n    size\n     total size in bytes\n    rw\n     binary trace for read/write request\n    opf\n     operations and flags\n    flags\n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid\n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n## Context\nThe process creating a block IO request.\n" },
    { "name": "tty.write", "doc": "## Name\nprobe::tty.write — \n     write to the tty line\n## Synopsis\n```\ntty.write \n```\n## Values\ndriver_name\n     the driver name\n    file_name\n     the file name lreated to the tty\n    nr\n     The amount of characters\n    buffer\n     the buffer that will be written\n" },
    { "name": "sunrpc.svc.destroy", "doc": "## Name\nprobe::sunrpc.svc.destroy — \n     Destroy an RPC service\n## Synopsis\n```\nsunrpc.svc.destroy \n```\n## Values\nsv_prog\n     the number of the program\n    nettcpconn\n     the count of accepted TCP connections\n    netcnt\n     the count of received RPC requests\n    sv_name\n     the service name\n    rpcbadfmt\n     the count of requests dropped for bad formats\n    rpcbadauth\n     the count of requests drooped for authentication failure\n    sv_progname\n     the name of the program\n    sv_nrthreads\n     the number of concurrent threads\n    rpccnt\n     the count of valid RPC requests\n" },
    { "name": "sunrpc.svc.process", "doc": "## Name\nprobe::sunrpc.svc.process — \n     Process an RPC request\n## Synopsis\n```\nsunrpc.svc.process \n```\n## Values\nsv_nrthreads\n     the number of concurrent threads\n    sv_name\n     the service name\n    peer_ip\n     the peer address where the request is from\n    rq_vers\n     the program version in the request\n    rq_prot\n     the IP protocol of the reqeust\n    rq_prog\n     the program number in the request\n    rq_proc\n     the procedure number in the request\n    sv_prog\n     the number of the program\n    rq_xid\n     the transmission id in the request\n" },
    { "name": "sunrpc.sched.release_task", "doc": "## Name\nprobe::sunrpc.sched.release_task — \n     Release all resources associated with a task\n## Synopsis\n```\nsunrpc.sched.release_task \n```\n## Values\nxid\n     the transmission id in the RPC call\n    vers\n     the program version in the RPC call\n    tk_flags\n     the flags of the task\n    prot\n     the IP protocol in the RPC call\n    prog\n     the program number in the RPC call\n## Description\nrpc_release_task function might not be found for a particular kernel.\n   So, if we can't find it, just return '-1' for everything.\n" },
    { "name": "scheduler.ctxswitch", "doc": "## Name\nprobe::scheduler.ctxswitch — \n     A context switch is occuring.\n## Synopsis\n```\nscheduler.ctxswitch \n```\n## Values\nnext_priority\n     The priority of the process to be switched in\n    prev_task_name\n     The name of the process to be switched out\n    prevtsk_state\n     the state of the process to be switched out\n    next_pid\n     The PID of the process to be switched in\n    prev_tid\n     The TID of the process to be switched out\n    prev_priority\n     The priority of the process to be switched out\n    nexttsk_state\n     the state of the process to be switched in\n    name\n     name of the probe point\n    next_task_name\n     The name of the process to be switched in\n    next_tid\n     The TID of the process to be switched in\t \n    prev_pid\n     The PID of the process to be switched out\n" },
    { "name": "tty.read", "doc": "## Name\nprobe::tty.read — \n     called when a tty line will be read\n## Synopsis\n```\ntty.read \n```\n## Values\ndriver_name\n     the driver name\n    file_name\n     the file name lreated to the tty\n    nr\n     The amount of characters to be read\n    buffer\n     the buffer that will receive the characters\n" },
    { "name": "socket.aio_write", "doc": "## Name\nprobe::socket.aio_write — \n     Message send via sock_aio_write\n## Synopsis\n```\nsocket.aio_write \n```\n## Values\nname\n     Name of this probe\n    type\n     Socket type value\n    protocol\n     Protocol value\n    family\n     Protocol family value\n    flags\n     Socket flags value\n    size\n     Message size in bytes\n    state\n     Socket state value\n## Context\nThe message sender\n## Description\nFires at the beginning of sending a message on a socket\n   via the sock_aio_write function\n" },
    { "name": "socket.aio_write.return", "doc": "## Name\nprobe::socket.aio_write.return — \n     Conclusion of message send via sock_aio_write\n## Synopsis\n```\nsocket.aio_write.return \n```\n## Values\nfamily\n     Protocol family value\n    flags\n     Socket flags value\n    state\n     Socket state value\n    size\n     Size of message received (in bytes) or error code if success = 0\n    type\n     Socket type value\n    success\n     Was receive successful? (1 = yes, 0 = no)\n    name\n     Name of this probe\n    protocol\n     Protocol value\n## Context\nThe message receiver.\n## Description\nFires at the conclusion of sending a message on a socket\n   via the sock_aio_write function\n" },
    { "name": "sunrpc.clnt.bind_new_program", "doc": "## Name\nprobe::sunrpc.clnt.bind_new_program — \n     Bind a new RPC program to an existing client\n## Synopsis\n```\nsunrpc.clnt.bind_new_program \n```\n## Values\nold_prog\n     the number of old RPC program\n    old_progname\n     the name of old RPC program\n    vers\n     the version of new RPC program\n    old_vers\n     the version of old RPC program\n    progname\n     the name of new RPC program\n    prog\n     the number of new RPC program\n    servername\n     the server machine name\n" },
    { "name": "tcp.setsockopt.return", "doc": "## Name\nprobe::tcp.setsockopt.return — \n     Return from setsockopt\n## Synopsis\n```\ntcp.setsockopt.return \n```\n## Values\nret\n     Error code (0: no error)\n    name\n     Name of this probe\n## Context\nThe process which calls setsockopt\n" },
    { "name": "socket.aio_read", "doc": "## Name\nprobe::socket.aio_read — \n     Receiving message via sock_aio_read\n## Synopsis\n```\nsocket.aio_read \n```\n## Values\nstate\n     Socket state value\n    size\n     Message size in bytes\n    flags\n     Socket flags value\n    family\n     Protocol family value\n    protocol\n     Protocol value\n    name\n     Name of this probe\n    type\n     Socket type value\n## Context\nThe message sender\n## Description\nFires at the beginning of receiving a message on a socket\n   via the sock_aio_read function\n" },
    { "name": "sunrpc.clnt.shutdown_client", "doc": "## Name\nprobe::sunrpc.clnt.shutdown_client — \n     Shutdown an RPC client\n## Synopsis\n```\nsunrpc.clnt.shutdown_client \n```\n## Values\nclones\n     the number of clones\n    om_bytes_recv\n     the count of bytes in\n    servername\n     the server machine name\n    om_rtt\n     the RPC RTT jiffies\n    om_execute\n     the RPC execution jiffies\n    tasks\n     the number of references\n    om_queue\n     the jiffies queued for xmit\n    port\n     the port number\n    prog\n     the RPC program number\n    netreconn\n     the count of reconnections\n    om_bytes_sent\n     the count of bytes out\n    om_ops\n     the count of operations\n    progname\n     the RPC program name\n    authflavor\n     the authentication flavor\n    prot\n     the IP protocol number\n    rpccnt\n     the count of RPC calls\n    vers\n     the RPC program version number\n    om_ntrans\n     the count of RPC transmissions\n" },
    { "name": "socket.close.return", "doc": "## Name\nprobe::socket.close.return — \n     Return from closing a socket\n## Synopsis\n```\nsocket.close.return \n```\n## Values\nname\n     Name of this probe\n## Context\nThe requester (user process or kernel)\n## Description\nFires at the conclusion of closing a socket.\n" },
    { "name": "socket.recvmsg.return", "doc": "## Name\nprobe::socket.recvmsg.return — \n     Return from Message being received on socket\n## Synopsis\n```\nsocket.recvmsg.return \n```\n## Values\nfamily\n     Protocol family value\n    flags\n     Socket flags value\n    size\n     Size of message received (in bytes) or error code if success = 0\n    state\n     Socket state value\n    name\n     Name of this probe\n    success\n     Was receive successful? (1 = yes, 0 = no)\n    type\n     Socket type value\n    protocol\n     Protocol value\n## Context\nThe message receiver.\n## Description\nFires at the conclusion of receiving a message on a socket\n   via the sock_recvmsg function.\n" },
    { "name": "udp.sendmsg.return", "doc": "## Name\nprobe::udp.sendmsg.return — \n     Fires whenever an attempt to send a UDP message is completed\n## Synopsis\n```\nudp.sendmsg.return \n```\n## Values\nname\n     The name of this probe\n    size\n     Number of bytes sent by the process\n## Context\nThe process which sent a UDP message\n" },
    { "name": "workqueue.execute", "doc": "## Name\nprobe::workqueue.execute — \n     Executing deferred work\n## Synopsis\n```\nworkqueue.execute \n```\n## Values\nwork_func\n     pointer to handler function\n    wq_thread\n     task_struct of the workqueue thread\n    work\n     work_struct* being executed\n" },
    { "name": "socket.send", "doc": "## Name\nprobe::socket.send — \n  Message sent on a socket.\n## Synopsis\n```\nsocket.send \n```\n## Values\nflags\n     Socket flags value\n    size\n     Size of message sent (in bytes) or error code if success = 0\n    state\n     Socket state value\n    family\n     Protocol family value\n    protocol\n     Protocol value\n    type\n     Socket type value\n    success\n     Was send successful? (1 = yes, 0 = no)\n    name\n     Name of this probe\n## Context\nThe message sender\n" },
    { "name": "socket.sendmsg", "doc": "## Name\nprobe::socket.sendmsg — \n     Message is currently being sent on a socket.\n## Synopsis\n```\nsocket.sendmsg \n```\n## Values\nfamily\n     Protocol family value\n    state\n     Socket state value\n    size\n     Message size in bytes\n    flags\n     Socket flags value\n    name\n     Name of this probe\n    type\n     Socket type value\n    protocol\n     Protocol value\n## Context\nThe message sender\n## Description\nFires at the beginning of sending a message on a socket\n   via the sock_sendmsg function\n" },
    { "name": "socket.create", "doc": "## Name\nprobe::socket.create — \n     Creation of a socket\n## Synopsis\n```\nsocket.create \n```\n## Values\nfamily\n     Protocol family value\n    requester\n     Requested by user process or the kernel (1 = kernel, 0 = user)\n    name\n     Name of this probe\n    type\n     Socket type value\n    protocol\n     Protocol value\n## Context\nThe requester (see requester variable)\n## Description\nFires at the beginning of creating a socket.\n" },
    { "name": "socket.read_iter.return", "doc": "## Name\nprobe::socket.read_iter.return — \n     Conclusion of message received via sock_read_iter\n## Synopsis\n```\nsocket.read_iter.return \n```\n## Values\ntype\n     Socket type value\n    success\n     Was receive successful? (1 = yes, 0 = no)\n    name\n     Name of this probe\n    protocol\n     Protocol value\n    family\n     Protocol family value\n    state\n     Socket state value\n    size\n     Size of message received (in bytes) or error code if success = 0\n    flags\n     Socket flags value\n## Context\nThe message receiver.\n## Description\nFires at the conclusion of receiving a message on a socket\n   via the sock_read_iter function\n" },
    { "name": "socket.readv", "doc": "## Name\nprobe::socket.readv — \n     Receiving a message via sock_readv\n## Synopsis\n```\nsocket.readv \n```\n## Values\nfamily\n     Protocol family value\n    flags\n     Socket flags value\n    state\n     Socket state value\n    size\n     Message size in bytes\n    name\n     Name of this probe\n    type\n     Socket type value\n    protocol\n     Protocol value\n## Context\nThe message sender\n## Description\nFires at the beginning of receiving a message on a socket\n   via the sock_readv function\n" },
    { "name": "socket.read_iter", "doc": "## Name\nprobe::socket.read_iter — \n     Receiving message via sock_read_iter\n## Synopsis\n```\nsocket.read_iter \n```\n## Values\nfamily\n     Protocol family value\n    flags\n     Socket flags value\n    state\n     Socket state value\n    size\n     Message size in bytes\n    name\n     Name of this probe\n    type\n     Socket type value\n    protocol\n     Protocol value\n## Context\nThe message sender\n## Description\nFires at the beginning of receiving a message on a socket\n   via the sock_read_iter function\n" },
    { "name": "ioscheduler_trace.elv_abort_request", "doc": "## Name\nprobe::ioscheduler_trace.elv_abort_request — \n     Fires when a request is aborted.\n## Synopsis\n```\nioscheduler_trace.elv_abort_request \n```\n## Values\nrq_flags\n     Request flags.\n    disk_minor\n     Disk minor number of request.\n    disk_major\n     Disk major no of request.\n    elevator_name\n     The type of I/O elevator currently enabled.\n    rq\n     Address of request.\n    name\n     Name of the probe point\n" },
    { "name": "netfilter.ip.post_routing", "doc": "## Name\nprobe::netfilter.ip.post_routing — \n     Called immediately before an outgoing IP packet leaves the computer\n## Synopsis\n```\nnetfilter.ip.post_routing \n```\n## Values\nindev_name\n     Name of network device packet was received on (if known)\n    rst\n     TCP RST flag (if protocol is TCP; ipv4 only)\n    psh\n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    length\n     The length of the packet buffer contents, in bytes\n    daddr\n     A string representing the destination IP address\n    protocol\n     Packet protocol from driver (ipv4 only)\n    data_str\n     A string representing the packet buffer contents\n    sport\n     TCP or UDP source port (ipv4 only)\n    fin\n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    urg\n     TCP URG flag (if protocol is TCP; ipv4 only)\n    family\n     IP address family\n    ipproto_tcp\n     Constant used to signify that the packet protocol is TCP\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    iphdr\n     Address of IP header\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    dport\n     TCP or UDP destination port (ipv4 only)\n    saddr\n     A string representing the source IP address\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    syn\n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    ipproto_udp\n     Constant used to signify that the packet protocol is UDP\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    pf\n     Protocol family -- either “ipv4” or “ipv6”\n    indev\n     Address of net_device representing input device, 0 if unknown\n    ack\n     TCP ACK flag (if protocol is TCP; ipv4 only)\n" },
    { "name": "socket.recvmsg", "doc": "## Name\nprobe::socket.recvmsg — \n     Message being received on socket\n## Synopsis\n```\nsocket.recvmsg \n```\n## Values\nfamily\n     Protocol family value\n    flags\n     Socket flags value\n    state\n     Socket state value\n    size\n     Message size in bytes\n    name\n     Name of this probe\n    type\n     Socket type value\n    protocol\n     Protocol value\n## Context\nThe message receiver.\n## Description\nFires at the beginning of receiving a message on a socket\n   via the sock_recvmsg function\n" },
    { "name": "socket.receive", "doc": "## Name\nprobe::socket.receive — \n     Message received on a socket.\n## Synopsis\n```\nsocket.receive \n```\n## Values\nstate\n     Socket state value\n    size\n     Size of message received (in bytes) or error code if success = 0\n    flags\n     Socket flags value\n    family\n     Protocol family value\n    protocol\n     Protocol value\n    type\n     Socket type value\n    success\n     Was send successful? (1 = yes, 0 = no)\n    name\n     Name of this probe\n## Context\nThe message receiver\n" },
    { "name": "sunrpc.svc.register", "doc": "## Name\nprobe::sunrpc.svc.register — \n     Register an RPC service with the local portmapper\n## Synopsis\n```\nsunrpc.svc.register \n```\n## Values\nprog\n     the number of the program\n    prot\n     the IP protocol number\n    progname\n     the name of the program\n    sv_name\n     the service name\n    port\n     the port number\n## Description\nIf proto and port are both 0, then unregister a service.\n" },
    { "name": "socket.write_iter", "doc": "## Name\nprobe::socket.write_iter — \n     Message send via sock_write_iter\n## Synopsis\n```\nsocket.write_iter \n```\n## Values\ntype\n     Socket type value\n    name\n     Name of this probe\n    protocol\n     Protocol value\n    family\n     Protocol family value\n    flags\n     Socket flags value\n    state\n     Socket state value\n    size\n     Message size in bytes\n## Context\nThe message sender\n## Description\nFires at the beginning of sending a message on a socket\n   via the sock_write_iter function\n" },
    { "name": "socket.close", "doc": "## Name\nprobe::socket.close — \n     Close a socket\n## Synopsis\n```\nsocket.close \n```\n## Values\nname\n     Name of this probe\n    type\n     Socket type value\n    protocol\n     Protocol value\n    family\n     Protocol family value\n    state\n     Socket state value\n    flags\n     Socket flags value\n## Context\nThe requester (user process or kernel)\n## Description\nFires at the beginning of closing a socket.\n" },
    { "name": "netdev.get_stats", "doc": "## Name\nprobe::netdev.get_stats — \n     Called when someone asks the device statistics\n## Synopsis\n```\nnetdev.get_stats \n```\n## Values\ndev_name\n     The device that is going to provide the statistics\n" },
    { "name": "ipmib.ForwDatagrams", "doc": "## Name\nprobe::ipmib.ForwDatagrams — \n     Count forwarded packet\n## Synopsis\n```\nipmib.ForwDatagrams \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    skb\n     pointer to the struct sk_buff being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global ForwDatagrams (equivalent to SNMP's MIB\n   IPSTATS_MIB_OUTFORWDATAGRAMS)\n" },
    { "name": "ipmib.FragFails", "doc": "## Name\nprobe::ipmib.FragFails — \n     Count datagram fragmented unsuccessfully\n## Synopsis\n```\nipmib.FragFails \n```\n## Values\nskb\n     pointer to the struct sk_buff being acted on\n    op\n     Value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global FragFails (equivalent to SNMP's MIB\n   IPSTATS_MIB_FRAGFAILS)\n" },
    { "name": "ipmib.FragOKs", "doc": "## Name\nprobe::ipmib.FragOKs — \n     Count datagram fragmented successfully\n## Synopsis\n```\nipmib.FragOKs \n```\n## Values\nskb\n     pointer to the struct sk_buff being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global FragOKs (equivalent to SNMP's MIB\n   IPSTATS_MIB_FRAGOKS)\n" },
    { "name": "ipmib.InAddrErrors", "doc": "## Name\nprobe::ipmib.InAddrErrors — \n     Count arriving packets with an incorrect address\n## Synopsis\n```\nipmib.InAddrErrors \n```\n## Values\nskb\n     pointer to the struct sk_buff being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InAddrErrors (equivalent to SNMP's MIB\n   IPSTATS_MIB_INADDRERRORS)\n" },
    { "name": "netfilter.bridge.local_in", "doc": "## Name\nprobe::netfilter.bridge.local_in — \n     Called on a bridging packet destined for the local computer\n## Synopsis\n```\nnetfilter.bridge.local_in \n```\n## Values\nindev_name\n     Name of network device packet was received on (if known)\n    br_cost\n     Total cost from transmitting bridge to root\n    br_htime\n     Hello time in 1/256 secs\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    length\n     The length of the packet buffer contents, in bytes\n    protocol\n     Packet protocol\n    data_str\n     A string representing the packet buffer contents\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    br_bid\n     Identity of bridge\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    brhdr\n     Address of bridge header\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    br_flags\n     BPDU flags\n    br_vid\n     Protocol version identifier\n    br_rmac\n     Root bridge MAC address\n    br_fd\n     Forward delay in 1/256 secs\n    br_max\n     Max age in 1/256 secs\n    br_rid\n     Identity of root bridge\n    llcproto_stp\n     Constant used to signify Bridge Spanning Tree Protocol packet\n    br_mac\n     Bridge MAC address\n    br_type\n     BPDU type\n    br_prid\n     Protocol identifier\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    nf_accept\n     Constant used to signify an 'accept' verdict\n    llcpdu\n     Address of LLC Protocol Data Unit\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    br_poid\n     Port identifier\n    pf\n     Protocol family -- always “bridge”\n    br_msg\n     Message age in 1/256 secs\n    indev\n     Address of net_device representing input device, 0 if unknown\n" },
    { "name": "netdev.receive", "doc": "## Name\nprobe::netdev.receive — \n  Data received from network device.\n## Synopsis\n```\nnetdev.receive \n```\n## Values\nprotocol\n     Protocol of received packet.\n    dev_name\n     The name of the device. e.g: eth0, ath1.\n    length\n     The length of the receiving buffer.\n" },
    { "name": "ipmib.InUnknownProtos", "doc": "## Name\nprobe::ipmib.InUnknownProtos — \n     Count arriving packets with an unbound proto\n## Synopsis\n```\nipmib.InUnknownProtos \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    skb\n     pointer to the struct sk_buff being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InUnknownProtos (equivalent to SNMP's MIB\n   IPSTATS_MIB_INUNKNOWNPROTOS)\n" },
    { "name": "socket.writev", "doc": "## Name\nprobe::socket.writev — \n     Message sent via socket_writev\n## Synopsis\n```\nsocket.writev \n```\n## Values\nflags\n     Socket flags value\n    state\n     Socket state value\n    size\n     Message size in bytes\n    family\n     Protocol family value\n    protocol\n     Protocol value\n    type\n     Socket type value\n    name\n     Name of this probe\n## Context\nThe message sender\n## Description\nFires at the beginning of sending a message on a socket\n   via the sock_writev function\n" },
    { "name": "socket.writev.return", "doc": "## Name\nprobe::socket.writev.return — \n     Conclusion of message sent via socket_writev\n## Synopsis\n```\nsocket.writev.return \n```\n## Values\nfamily\n     Protocol family value\n    state\n     Socket state value\n    size\n     Size of message sent (in bytes) or error code if success = 0\n    flags\n     Socket flags value\n    type\n     Socket type value\n    success\n     Was send successful? (1 = yes, 0 = no)\n    name\n     Name of this probe\n    protocol\n     Protocol value\n## Context\nThe message receiver.\n## Description\nFires at the conclusion of sending a message on a socket\n   via the sock_writev function\n" },
    { "name": "linuxmib.DelayedACKs", "doc": "## Name\nprobe::linuxmib.DelayedACKs — \n  Count of delayed acks\n## Synopsis\n```\nlinuxmib.DelayedACKs \n```\n## Values\nsk\n     Pointer to the struct sock being acted on\n    op\n     Value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   linuxmib_filter_key. If the packet passes the filter is is\n   counted in the global DelayedACKs (equivalent to SNMP's MIB\n   LINUX_MIB_DELAYEDACKS)\n" },
    { "name": "udp.disconnect", "doc": "## Name\nprobe::udp.disconnect — \n     Fires when a process requests for a UDP disconnection\n## Synopsis\n```\nudp.disconnect \n```\n## Values\nfamily\n     IP address family\n    saddr\n     A string representing the source IP address\n    dport\n     UDP destination port\n    daddr\n     A string representing the destination IP address\n    flags\n     Flags (e.g. FIN, etc)  \n    sport\n     UDP source port\n    name\n     The name of this probe\n    sock\n     Network socket used by the process\n## Context\nThe process which requests a UDP disconnection\n" },
    { "name": "linuxmib.ListenDrops", "doc": "## Name\nprobe::linuxmib.ListenDrops — \n     Count of times conn request that were dropped\n## Synopsis\n```\nlinuxmib.ListenDrops \n```\n## Values\nop\n     Value to be added to the counter (default value of 1)\n    sk\n     Pointer to the struct sock being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   linuxmib_filter_key. If the packet passes the filter is is\n   counted in the global ListenDrops (equivalent to SNMP's MIB\n   LINUX_MIB_LISTENDROPS)\n" },
    { "name": "ipmib.ReasmReqds", "doc": "## Name\nprobe::ipmib.ReasmReqds — \n     Count number of packet fragments reassembly requests\n## Synopsis\n```\nipmib.ReasmReqds \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    skb\n     pointer to the struct sk_buff being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global ReasmReqds (equivalent to SNMP's MIB\n   IPSTATS_MIB_REASMREQDS)\n" },
    { "name": "linuxmib.ListenOverflows", "doc": "## Name\nprobe::linuxmib.ListenOverflows — \n     Count of times a listen queue overflowed\n## Synopsis\n```\nlinuxmib.ListenOverflows \n```\n## Values\nsk\n     Pointer to the struct sock being acted on\n    op\n     Value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   linuxmib_filter_key. If the packet passes the filter is is\n   counted in the global ListenOverflows (equivalent to SNMP's MIB\n   LINUX_MIB_LISTENOVERFLOWS)\n" },
    { "name": "tcpmib.ActiveOpens", "doc": "## Name\nprobe::tcpmib.ActiveOpens — \n     Count an active opening of a socket\n## Synopsis\n```\ntcpmib.ActiveOpens \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    sk\n     pointer to the struct sock being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global ActiveOpens (equivalent to SNMP's MIB\n   TCP_MIB_ACTIVEOPENS)\n" },
    { "name": "tcpmib.EstabResets", "doc": "## Name\nprobe::tcpmib.EstabResets — \n     Count the reset of a socket\n## Synopsis\n```\ntcpmib.EstabResets \n```\n## Values\nsk\n     pointer to the struct sock being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global EstabResets (equivalent to SNMP's MIB\n   TCP_MIB_ESTABRESETS)\n" },
    { "name": "tcpmib.AttemptFails", "doc": "## Name\nprobe::tcpmib.AttemptFails — \n     Count a failed attempt to open a socket\n## Synopsis\n```\ntcpmib.AttemptFails \n```\n## Values\nsk\n     pointer to the struct sock being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global AttemptFails (equivalent to SNMP's MIB\n   TCP_MIB_ATTEMPTFAILS)\n" },
    { "name": "tcpmib.OutSegs", "doc": "## Name\nprobe::tcpmib.OutSegs — \n     Count the sending of a TCP segment\n## Synopsis\n```\ntcpmib.OutSegs \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    sk\n     pointer to the struct sock being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global OutSegs (equivalent to SNMP's MIB\n   TCP_MIB_OUTSEGS)\n" },
    { "name": "tcpmib.CurrEstab", "doc": "## Name\nprobe::tcpmib.CurrEstab — \n     Update the count of open sockets\n## Synopsis\n```\ntcpmib.CurrEstab \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    sk\n     pointer to the struct sock being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global CurrEstab (equivalent to SNMP's MIB\n   TCP_MIB_CURRESTAB)\n" },
    { "name": "tcpmib.PassiveOpens", "doc": "## Name\nprobe::tcpmib.PassiveOpens — \n     Count the passive creation of a socket\n## Synopsis\n```\ntcpmib.PassiveOpens \n```\n## Values\nsk\n     pointer to the struct sock being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global PassiveOpens (equivalent to SNMP's MIB\n   TCP_MIB_PASSIVEOPENS)\n" },
    { "name": "kprocess.create", "doc": "## Name\nprobe::kprocess.create — \n  Fires whenever a new process or thread is successfully created\n## Synopsis\n```\nkprocess.create \n```\n## Values\nnew_tid\n     The TID of the newly created task\n    new_pid\n     The PID of the newly created process\n## Context\nParent of the created process.\n## Description\nFires whenever a new process is successfully created, either as a result of\n   fork (or one of its syscall variants), or a new kernel thread.\n" },
    { "name": "tcpmib.OutRsts", "doc": "## Name\nprobe::tcpmib.OutRsts — \n     Count the sending of a reset packet\n## Synopsis\n```\ntcpmib.OutRsts \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    sk\n     pointer to the struct sock being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global OutRsts (equivalent to SNMP's MIB\n   TCP_MIB_OUTRSTS)\n" },
    { "name": "socket.write_iter.return", "doc": "## Name\nprobe::socket.write_iter.return — \n     Conclusion of message send via sock_write_iter\n## Synopsis\n```\nsocket.write_iter.return \n```\n## Values\nfamily\n     Protocol family value\n    flags\n     Socket flags value\n    state\n     Socket state value\n    size\n     Size of message received (in bytes) or error code if success = 0\n    name\n     Name of this probe\n    success\n     Was receive successful? (1 = yes, 0 = no)\n    type\n     Socket type value\n    protocol\n     Protocol value\n## Context\nThe message receiver.\n## Description\nFires at the conclusion of sending a message on a socket\n   via the sock_write_iter function\n" },
    { "name": "kprocess.exec", "doc": "## Name\nprobe::kprocess.exec — \n     Attempt to exec to a new program\n## Synopsis\n```\nkprocess.exec \n```\n## Values\nargs\n     The arguments to pass to the new executable, including\n     the 0th arg (SystemTap v2.5+)\n    argstr\n     A string containing the filename followed by the\n     arguments to pass, excluding 0th arg (SystemTap v2.5+)\n    name\n     Name of the system call (“execve”) (SystemTap v2.5+)\n    filename\n     The path to the new executable\n## Context\nThe caller of exec.\n## Description\nFires whenever a process attempts to exec to a new program. Aliased\n   to the syscall.execve probe in SystemTap v2.5+.\n" },
    { "name": "socket.aio_read.return", "doc": "## Name\nprobe::socket.aio_read.return — \n     Conclusion of message received via sock_aio_read\n## Synopsis\n```\nsocket.aio_read.return \n```\n## Values\nflags\n     Socket flags value\n    size\n     Size of message received (in bytes) or error code if success = 0\n    state\n     Socket state value\n    family\n     Protocol family value\n    protocol\n     Protocol value\n    name\n     Name of this probe\n    success\n     Was receive successful? (1 = yes, 0 = no)\n    type\n     Socket type value\n## Context\nThe message receiver.\n## Description\nFires at the conclusion of receiving a message on a socket\n   via the sock_aio_read function\n" },
    { "name": "kprocess.exit", "doc": "## Name\nprobe::kprocess.exit — \n     Exit from process\n## Synopsis\n```\nkprocess.exit \n```\n## Values\ncode\n     The exit code of the process\n## Context\nThe process which is terminating.\n## Description\nFires when a process terminates.  This will always be followed by a\n   kprocess.release, though the latter may be delayed if the process waits in a\n   zombie state.\n" },
    { "name": "netfilter.ip.local_out", "doc": "## Name\nprobe::netfilter.ip.local_out — \n     Called on an outgoing IP packet\n## Synopsis\n```\nnetfilter.ip.local_out \n```\n## Values\nrst\n     TCP RST flag (if protocol is TCP; ipv4 only)\n    indev_name\n     Name of network device packet was received on (if known)\n    psh\n     TCP PSH flag (if protocol is TCP; ipv4 only)\n    nf_stolen\n     Constant used to signify a 'stolen' verdict\n    fin\n     TCP FIN flag (if protocol is TCP; ipv4 only)\n    urg\n     TCP URG flag (if protocol is TCP; ipv4 only)\n    protocol\n     Packet protocol from driver (ipv4 only)\n    daddr\n     A string representing the destination IP address\n    length\n     The length of the packet buffer contents, in bytes\n    nf_stop\n     Constant used to signify a 'stop' verdict\n    sport\n     TCP or UDP source port (ipv4 only)\n    data_str\n     A string representing the packet buffer contents\n    dport\n     TCP or UDP destination port (ipv4 only)\n    data_hex\n     A hexadecimal string representing the packet buffer contents\n    iphdr\n     Address of IP header\n    saddr\n     A string representing the source IP address\n    nf_drop\n     Constant used to signify a 'drop' verdict\n    ipproto_tcp\n     Constant used to signify that the packet protocol is TCP\n    family\n     IP address family\n    outdev\n     Address of net_device representing output device, 0 if unknown\n    pf\n     Protocol family -- either “ipv4” or “ipv6”\n    outdev_name\n     Name of network device packet will be routed to (if known)\n    nf_queue\n     Constant used to signify a 'queue' verdict\n    ack\n     TCP ACK flag (if protocol is TCP; ipv4 only)\n    indev\n     Address of net_device representing input device, 0 if unknown\n    nf_repeat\n     Constant used to signify a 'repeat' verdict\n    ipproto_udp\n     Constant used to signify that the packet protocol is UDP\n    syn\n     TCP SYN flag (if protocol is TCP; ipv4 only)\n    nf_accept\n     Constant used to signify an 'accept' verdict\n" },
    { "name": "kprocess.start", "doc": "## Name\nprobe::kprocess.start — \n     Starting new process\n## Synopsis\n```\nkprocess.start \n```\n## Values\nNone\n## Context\nNewly created process.\n## Description\nFires immediately before a new process begins execution.\n" },
    { "name": "linuxmib.TCPMemoryPressures", "doc": "## Name\nprobe::linuxmib.TCPMemoryPressures — \n     Count of times memory pressure was used\n## Synopsis\n```\nlinuxmib.TCPMemoryPressures \n```\n## Values\nsk\n     Pointer to the struct sock being acted on\n    op\n     Value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   linuxmib_filter_key. If the packet passes the filter is is\n   counted in the global TCPMemoryPressures (equivalent to SNMP's MIB\n   LINUX_MIB_TCPMEMORYPRESSURES)\n" },
    { "name": "socket.readv.return", "doc": "## Name\nprobe::socket.readv.return — \n     Conclusion of receiving a message via sock_readv\n## Synopsis\n```\nsocket.readv.return \n```\n## Values\nname\n     Name of this probe\n    success\n     Was receive successful? (1 = yes, 0 = no)\n    type\n     Socket type value\n    protocol\n     Protocol value\n    family\n     Protocol family value\n    state\n     Socket state value\n    size\n     Size of message received (in bytes) or error code if success = 0\n    flags\n     Socket flags value\n## Context\nThe message receiver.\n## Description\nFires at the conclusion of receiving a message on a socket\n   via the sock_readv function\n" },
    { "name": "signal.check_ignored.return", "doc": "## Name\nprobe::signal.check_ignored.return — \n     Check to see signal is ignored completed\n## Synopsis\n```\nsignal.check_ignored.return \n```\n## Values\nretstr\n     Return value as a string\n    name\n     Name of the probe point\n" },
    { "name": "signal.force_segv.return", "doc": "## Name\nprobe::signal.force_segv.return — \n     Forcing send of SIGSEGV complete\n## Synopsis\n```\nsignal.force_segv.return \n```\n## Values\nname\n     Name of the probe point\n    retstr\n     Return value as a string\n" },
    { "name": "signal.do_action", "doc": "## Name\nprobe::signal.do_action — \n     Examining or changing a signal action\n## Synopsis\n```\nsignal.do_action \n```\n## Values\nsig_name\n     A string representation of the signal\n    sa_mask\n     The new mask of the signal\n    name\n     Name of the probe point\n    sa_handler\n     The new handler of the signal\n    sigact_addr\n     The address of the new sigaction\n     struct associated with the signal\n    oldsigact_addr\n     The address of the old sigaction\n     struct associated with the signal\n    sig\n     The signal to be examined/changed\n" },
    { "name": "signal.handle.return", "doc": "## Name\nprobe::signal.handle.return — \n     Signal handler invocation completed\n## Synopsis\n```\nsignal.handle.return \n```\n## Values\nname\n     Name of the probe point\n    retstr\n     Return value as a string\n## Description\n(deprecated in SystemTap 2.1)\n" },
    { "name": "signal.pending", "doc": "## Name\nprobe::signal.pending — \n     Examining pending signal\n## Synopsis\n```\nsignal.pending \n```\n## Values\nsigset_add\n     The address of the user-space signal set\n     (sigset_t)\n    sigset_size\n     The size of the user-space signal set\n    name\n     Name of the probe point\n## Description\nThis probe is used to examine a set of signals pending for delivery\n   to a specific thread. This normally occurs when the\n   do_sigpending kernel function is executed.\n" },
    { "name": "signal.pending.return", "doc": "## Name\nprobe::signal.pending.return — \n     Examination of pending signal completed\n## Synopsis\n```\nsignal.pending.return \n```\n## Values\nname\n     Name of the probe point\n    retstr\n     Return value as a string\n" },
    { "name": "signal.do_action.return", "doc": "## Name\nprobe::signal.do_action.return — \n     Examining or changing a signal action completed\n## Synopsis\n```\nsignal.do_action.return \n```\n## Values\nname\n     Name of the probe point\n    retstr\n     Return value as a string\n" },
    { "name": "signal.send", "doc": "## Name\nprobe::signal.send — \n  Signal being sent to a process\n## Synopsis\n```\nsignal.send \n```\n## Values\nsi_code\n     Indicates the signal type\n    pid_name\n     The name of the signal recipient\n    shared\n     Indicates whether the signal is shared by the thread group\n    sinfo\n     The address of siginfo struct\n    name\n     The name of the function used to send out the signal\n    sig_pid\n     The PID of the process receiving the signal\n    sig_name\n     A string representation of the signal\n    sig\n     The number of the signal\n    task\n     A task handle to the signal recipient\n    send2queue\n     Indicates whether the signal is sent to an existing\n     sigqueue (deprecated in SystemTap 2.1)\n## Context\nThe signal's sender.\n" },
    { "name": "ipmib.InNoRoutes", "doc": "## Name\nprobe::ipmib.InNoRoutes — \n     Count an arriving packet with no matching socket\n## Synopsis\n```\nipmib.InNoRoutes \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    skb\n     pointer to the struct sk_buff being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InNoRoutes (equivalent to SNMP's MIB\n   IPSTATS_MIB_INNOROUTES)\n" },
    { "name": "kprocess.release", "doc": "## Name\nprobe::kprocess.release — \n     Process released\n## Synopsis\n```\nkprocess.release \n```\n## Values\ntask\n     A task handle to the process being released\n    released_tid\n     TID of the task being released\n    released_pid\n     PID of the process being released\n    pid\n     Same as released_pid for compatibility (deprecated)\n## Context\nThe context of the parent, if it wanted notification of this process'\n   termination, else the context of the process itself.\n## Description\nFires when a process is released from the kernel.  This always follows a\n   kprocess.exit, though it may be delayed somewhat if the process waits in a\n   zombie state.\n" },
    { "name": "signal.send_sig_queue", "doc": "## Name\nprobe::signal.send_sig_queue — \n     Queuing a signal to a process\n## Synopsis\n```\nsignal.send_sig_queue \n```\n## Values\nsig\n     The queued signal\n    name\n     Name of the probe point\n    sig_pid\n     The PID of the process to which the signal is queued\n    sig_name\n     A string representation of the signal\n    pid_name\n     Name of the process to which the signal is queued\n    sigqueue_addr\n     The address of the signal queue\n" },
    { "name": "socket.sendmsg.return", "doc": "## Name\nprobe::socket.sendmsg.return — \n     Return from socket.sendmsg.\n## Synopsis\n```\nsocket.sendmsg.return \n```\n## Values\nflags\n     Socket flags value\n    size\n     Size of message sent (in bytes) or error code if success = 0\n    state\n     Socket state value\n    family\n     Protocol family value\n    protocol\n     Protocol value\n    type\n     Socket type value\n    success\n     Was send successful? (1 = yes, 0 = no)\n    name\n     Name of this probe\n## Context\nThe message sender.\n## Description\nFires at the conclusion of sending a message on a socket\n   via the sock_sendmsg function\n" },
    { "name": "signal.send_sig_queue.return", "doc": "## Name\nprobe::signal.send_sig_queue.return — \n     Queuing a signal to a process completed\n## Synopsis\n```\nsignal.send_sig_queue.return \n```\n## Values\nretstr\n     Return value as a string\n    name\n     Name of the probe point\n" },
    { "name": "signal.handle", "doc": "## Name\nprobe::signal.handle — \n     Signal handler being invoked\n## Synopsis\n```\nsignal.handle \n```\n## Values\nsig\n     The signal number that invoked the signal handler\n    oldset_addr\n     The address of the bitmask array of blocked signals\n     (deprecated in SystemTap 2.1)\n    ka_addr\n     The address of the k_sigaction table\n     associated with the signal\n    regs\n     The address of the kernel-mode stack area (deprecated in\n     SystemTap 2.1)\n    sig_code\n     The si_code value of the siginfo signal\n    sig_name\n     A string representation of the signal\n    sig_mode\n     Indicates whether the signal was a user-mode or kernel-mode signal\n    name\n     Name of the probe point\n    sinfo\n     The address of the siginfo table\n" },
    { "name": "signal.sys_tgkill", "doc": "## Name\nprobe::signal.sys_tgkill — \n     Sending kill signal to a thread group\n## Synopsis\n```\nsignal.sys_tgkill \n```\n## Values\nname\n     Name of the probe point\n    sig_name\n     A string representation of the signal\n    sig_pid\n     The PID of the thread receiving the kill signal\n    pid_name\n     The name of the signal recipient\n    task\n     A task handle to the signal recipient\n    sig\n     The specific kill signal sent to the process\n    tgid\n     The thread group ID of the thread receiving the kill signal\n## Description\nThe tgkill call is similar to tkill,\n   except that it also allows the caller to specify the thread group ID of\n   the thread to be signalled. This protects against TID reuse.\n" },
    { "name": "tty.receive", "doc": "## Name\nprobe::tty.receive — \n     called when a tty receives a message\n## Synopsis\n```\ntty.receive \n```\n## Values\nindex\n     The tty Index\n    count\n     The amount of characters received\n    id\n     the tty id\n    driver_name\n     the driver name\n    fp\n     The flag buffer\n    cp\n     the buffer that was received\n    name\n     the name of the module file\n" },
    { "name": "signal.sys_tgkill.return", "doc": "## Name\nprobe::signal.sys_tgkill.return — \n     Sending kill signal to a thread group completed\n## Synopsis\n```\nsignal.sys_tgkill.return \n```\n## Values\nretstr\n     The return value to either __group_send_sig_info,\n    name\n     Name of the probe point\n" },
    { "name": "ipmib.ReasmTimeout", "doc": "## Name\nprobe::ipmib.ReasmTimeout — \n     Count Reassembly Timeouts\n## Synopsis\n```\nipmib.ReasmTimeout \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    skb\n     pointer to the struct sk_buff being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global ReasmTimeout (equivalent to SNMP's MIB\n   IPSTATS_MIB_REASMTIMEOUT)\n" },
    { "name": "signal.syskill.return", "doc": "## Name\nprobe::signal.syskill.return — \n     Sending kill signal completed\n## Synopsis\n```\nsignal.syskill.return \n```\n## Values\nNone\n" },
    { "name": "kprocess.exec_complete", "doc": "## Name\nprobe::kprocess.exec_complete — \n     Return from exec to a new program\n## Synopsis\n```\nkprocess.exec_complete \n```\n## Values\nsuccess\n     A boolean indicating whether the exec was successful\n    errno\n     The error number resulting from the exec\n    name\n     Name of the system call (“execve”) (SystemTap v2.5+)\n    retstr\n     A string representation of errno (SystemTap v2.5+)\n## Context\nOn success, the context of the new executable.\n   On failure, remains in the context of the caller.\n## Description\nFires at the completion of an exec call. Aliased to the\n   syscall.execve.return probe in SystemTap v2.5+.\n" },
    { "name": "signal.checkperm", "doc": "## Name\nprobe::signal.checkperm — \n     Check being performed on a sent signal\n## Synopsis\n```\nsignal.checkperm \n```\n## Values\nname\n     Name of the probe point\n    sinfo\n     The address of the siginfo structure\n    sig_name\n     A string representation of the signal\n    sig_pid\n     The PID of the process receiving the signal\n    si_code\n     Indicates the signal type\n    pid_name\n     Name of the process receiving the signal\n    task\n     A task handle to the signal recipient\n    sig\n     The number of the signal\n" },
    { "name": "ipmib.InReceives", "doc": "## Name\nprobe::ipmib.InReceives — \n     Count an arriving packet\n## Synopsis\n```\nipmib.InReceives \n```\n## Values\nop\n     value to be added to the counter (default value of 1)\n    skb\n     pointer to the struct sk_buff being acted on\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InReceives (equivalent to SNMP's MIB\n   IPSTATS_MIB_INRECEIVES)\n" },
    { "name": "signal.systkill.return", "doc": "## Name\nprobe::signal.systkill.return — \n     Sending kill signal to a thread completed\n## Synopsis\n```\nsignal.systkill.return \n```\n## Values\nname\n     Name of the probe point\n    retstr\n     The return value to either __group_send_sig_info,\n" },
    { "name": "ipmib.InDiscards", "doc": "## Name\nprobe::ipmib.InDiscards — \n     Count discarded inbound packets\n## Synopsis\n```\nipmib.InDiscards \n```\n## Values\nskb\n     pointer to the struct sk_buff being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global InDiscards (equivalent to SNMP's MIB\n   STATS_MIB_INDISCARDS)\n" },
    { "name": "signal.send.return", "doc": "## Name\nprobe::signal.send.return — \n     Signal being sent to a process completed (deprecated in SystemTap 2.1)\n## Synopsis\n```\nsignal.send.return \n```\n## Values\nretstr\n     The return value to either __group_send_sig_info, specific_send_sig_info, or send_sigqueue\n    send2queue\n     Indicates whether the sent signal was sent to an existing sigqueue\n    shared\n     Indicates whether the sent signal is shared by the thread group.\n    name\n     The name of the function used to send out the signal\n## Context\nThe signal's sender. (correct?)\n## Description\nPossible __group_send_sig_info and\n   specific_send_sig_info return values are as follows;\n0 -- The signal is successfully sent to a process,\n   which means that, (1) the signal was ignored by the receiving process,\n   (2) this is a non-RT signal and the system already has one queued, and\n   (3) the signal was successfully added to the sigqueue of the receiving process.\n-EAGAIN -- The sigqueue of the receiving process is\n   overflowing, the signal was RT, and the signal was sent by a user using something other\n   than kill.\nPossible send_group_sigqueue and\n   send_sigqueue return values are as follows;\n0 -- The signal was either successfully added into the\n   sigqueue of the receiving process, or a SI_TIMER entry is already\n   queued (in which case, the overrun count will be simply incremented).\n1 -- The signal was ignored by the receiving process.\n-1 -- (send_sigqueue only) The task was marked\n   exiting, allowing * posix_timer_event to redirect it to the group\n   leader.\n" },
    { "name": "signal.flush", "doc": "## Name\nprobe::signal.flush — \n     Flushing all pending signals for a task\n## Synopsis\n```\nsignal.flush \n```\n## Values\npid_name\n     The name of the process associated with the task\n     performing the flush\n    sig_pid\n     The PID of the process associated with the task\n     performing the flush\n    name\n     Name of the probe point\n    task\n     The task handler of the process performing the flush\n" },
    { "name": "signal.wakeup", "doc": "## Name\nprobe::signal.wakeup — \n     Sleeping process being wakened for signal\n## Synopsis\n```\nsignal.wakeup \n```\n## Values\nstate_mask\n     A string representation indicating the mask\n     of task states to wake. Possible values are\n     TASK_INTERRUPTIBLE, TASK_STOPPED,\n     TASK_TRACED, TASK_WAKEKILL, and TASK_INTERRUPTIBLE.\n    sig_pid\n     The PID of the process to wake\n    pid_name\n     Name of the process to wake\n    resume\n     Indicates whether to wake up a task in a\n     STOPPED or TRACED state\n" },
    { "name": "tcpmib.RetransSegs", "doc": "## Name\nprobe::tcpmib.RetransSegs — \n     Count the retransmission of a TCP segment\n## Synopsis\n```\ntcpmib.RetransSegs \n```\n## Values\nsk\n     pointer to the struct sock being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key. If the packet passes the filter is is\n   counted in the global RetransSegs (equivalent to SNMP's MIB\n   TCP_MIB_RETRANSSEGS)\n" },
    { "name": "signal.checkperm.return", "doc": "## Name\nprobe::signal.checkperm.return — \n     Check performed on a sent signal completed\n## Synopsis\n```\nsignal.checkperm.return \n```\n## Values\nretstr\n     Return value as a string\n    name\n     Name of the probe point\n" },
    { "name": "tcp.recvmsg", "doc": "## Name\nprobe::tcp.recvmsg — \n     Receiving TCP message\n## Synopsis\n```\ntcp.recvmsg \n```\n## Values\ndport\n     TCP destination port\n    sock\n     Network socket\n    size\n     Number of bytes to be received  \n    sport\n     TCP source port \n    saddr\n     A string representing the source IP address\n    daddr\n     A string representing the destination IP address\n    family\n     IP address family\n    name\n     Name of this probe\n## Context\nThe process which receives a tcp message\n" },
    { "name": "tcpmib.InSegs", "doc": "## Name\nprobe::tcpmib.InSegs — \n     Count an incoming tcp segment\n## Synopsis\n```\ntcpmib.InSegs \n```\n## Values\nsk\n     pointer to the struct sock being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   tcpmib_filter_key (or ipmib_filter_key for tcp v4).\n   If the packet passes the filter is is\n   counted in the global InSegs (equivalent to SNMP's MIB\n   TCP_MIB_INSEGS)\n" },
    { "name": "ioscheduler_trace.elv_completed_request", "doc": "## Name\nprobe::ioscheduler_trace.elv_completed_request — \n     Fires when a request is\n## Synopsis\n```\nioscheduler_trace.elv_completed_request \n```\n## Values\nrq_flags\n     Request flags.\n    disk_minor\n     Disk minor number of request.\n    disk_major\n     Disk major no of request.\n    elevator_name\n     The type of I/O elevator currently enabled.\n    name\n     Name of the probe point\n    rq\n     Address of request.\n## Description\ncompleted.\n" },
    { "name": "signal.sys_tkill", "doc": "## Name\nprobe::signal.sys_tkill — \n     Sending a kill signal to a thread\n## Synopsis\n```\nsignal.sys_tkill \n```\n## Values\ntask\n     A task handle to the signal recipient\n    sig\n     The specific signal sent to the process\n    name\n     Name of the probe point\n    sig_name\n     A string representation of the signal\n    sig_pid\n     The PID of the process receiving the kill signal\n    pid_name\n     The name of the signal recipient\n## Description\nThe tkill call is analogous to kill(2),\n   except that it also allows a process within a specific thread group to\n   be targeted. Such processes are targeted through their unique\n   thread IDs (TID).\n" },
    { "name": "ipmib.OutRequests", "doc": "## Name\nprobe::ipmib.OutRequests — \n     Count a request to send a packet\n## Synopsis\n```\nipmib.OutRequests \n```\n## Values\nskb\n     pointer to the struct sk_buff being acted on\n    op\n     value to be added to the counter (default value of 1)\n## Description\nThe packet pointed to by skb is filtered by the function\n   ipmib_filter_key. If the packet passes the filter is is\n   counted in the global OutRequests (equivalent to SNMP's MIB\n   IPSTATS_MIB_OUTREQUESTS)\n" },
    { "name": "signal.check_ignored", "doc": "## Name\nprobe::signal.check_ignored — \n     Checking to see signal is ignored\n## Synopsis\n```\nsignal.check_ignored \n```\n## Values\npid_name\n     Name of the process receiving the signal\n    sig_pid\n     The PID of the process receiving the signal\n    sig_name\n     A string representation of the signal\n    sig\n     The number of the signal\n" },
    { "name": "ioblock_trace.end", "doc": "## Name\nprobe::ioblock_trace.end — \n     Fires whenever a block I/O transfer is complete.\n## Synopsis\n```\nioblock_trace.end \n```\n## Values\nidx\n     offset into the bio vector array\n     phys_segments - number of segments in this bio after physical address coalescing is performed.\n    ino\n     i-node number of the mapped file\n    bytes_done\n     number of bytes transferred\n    q\n     request queue on which this bio was queued.\n    sector\n     beginning sector for the entire bio\n    name\n     name of the probe point\n    bdev_contains\n     points to the device object which contains the partition (when bio structure represents a partition)\n    p_start_sect\n     points to the start sector of the partition structure of the device\n    devname\n     block device name\n    bdev\n     target block device\n    size\n     total size in bytes\n    vcnt\n     bio vector count which represents number of array element (page, offset, length) which makes up this I/O request\n    rw\n     binary trace for read/write request\n    flags\n     see below\n     BIO_UPTODATE    0       ok after I/O completion\n     BIO_RW_BLOCK    1       RW_AHEAD set, and read/write would block\n     BIO_EOF         2       out-out-bounds error\n     BIO_SEG_VALID   3       nr_hw_seg valid\n     BIO_CLONED      4       doesn't own data\n     BIO_BOUNCED     5       bio is a bounce bio\n     BIO_USER_MAPPED 6       contains user pages\n     BIO_EOPNOTSUPP  7       not supported\n    opf\n     operations and flags\n## Context\nThe process signals the transfer is done.\n" },
    { "name": "signal.procmask", "doc": "## Name\nprobe::signal.procmask — \n     Examining or changing blocked signals\n## Synopsis\n```\nsignal.procmask \n```\n## Values\nsigset\n     The actual value to be set for sigset_t\n     (correct?)\n    how\n     Indicates how to change the blocked signals; possible values are\n     SIG_BLOCK=0 (for blocking signals),\n     SIG_UNBLOCK=1 (for unblocking signals), and\n     SIG_SETMASK=2 for setting the signal mask.\n    name\n     Name of the probe point\n    sigset_addr\n     The address of the signal set (sigset_t)\n     to be implemented\n    oldsigset_addr\n     The old address of the signal set\n     (sigset_t)\n" },
    { "name": "signal.procmask.return", "doc": "## Name\nprobe::signal.procmask.return — \n     Examining or changing blocked signals completed\n## Synopsis\n```\nsignal.procmask.return \n```\n## Values\nname\n     Name of the probe point\n    retstr\n     Return value as a string\n" },
    { "name": "stap.cache_add_mod", "doc": "## Name\nprobe::stap.cache_add_mod — \n     Adding kernel instrumentation module to cache\n## Synopsis\n```\nstap.cache_add_mod \n```\n## Values\ndest_path\n     the path the .ko file is going to (incl filename)\n    source_path\n     the path the .ko file is coming from (incl filename)\n## Description\nFires just before the file is actually moved. Note: if moving fails,\n   cache_add_src and cache_add_nss will not fire.\n" },
    { "name": "stap.cache_add_nss", "doc": "## Name\nprobe::stap.cache_add_nss — \n     Add NSS (Network Security Services) information to cache\n## Synopsis\n```\nstap.cache_add_nss \n```\n## Values\ndest_path\n     the path the .sgn file is coming from (incl filename)\n    source_path\n     the path the .sgn file is coming from (incl filename)\n## Description\nFires just before the file is actually moved. Note: stap must compiled\n   with NSS support; if moving the kernel module fails, this probe will\n   not fire.\n" },
    { "name": "stap.cache_add_src", "doc": "## Name\nprobe::stap.cache_add_src — \n     Adding C code translation to cache\n## Synopsis\n```\nstap.cache_add_src \n```\n## Values\ndest_path\n     the path the .c file is going to (incl filename)\n    source_path\n     the path the .c file is coming from (incl filename)\n## Description\nFires just before the file is actually moved. Note: if moving the\n   kernel module fails, this probe will not fire.\n" },
    { "name": "stap.cache_clean", "doc": "## Name\nprobe::stap.cache_clean — \n     Removing file from stap cache\n## Synopsis\n```\nstap.cache_clean \n```\n## Values\npath\n     the path to the .ko/.c file being removed\n## Description\nFires just before the call to unlink the module/source file.\n" },
    { "name": "stap.pass0.end", "doc": "## Name\nprobe::stap.pass0.end — \n     Finished stap pass0 (parsing command line arguments)\n## Synopsis\n```\nstap.pass0.end \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass0.end fires just before the gettimeofday call for pass1.\n" },
    { "name": "stap.pass1a", "doc": "## Name\nprobe::stap.pass1a — \n     Starting stap pass1 (parsing user script)\n## Synopsis\n```\nstap.pass1a \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass1a fires just after the call to gettimeofday, before the\n   user script is parsed.\n" },
    { "name": "stap.pass2.end", "doc": "## Name\nprobe::stap.pass2.end — \n     Finished stap pass2 (elaboration)\n## Synopsis\n```\nstap.pass2.end \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass2.end fires just before the jump to cleanup if s.last_pass = 2\n" },
    { "name": "stap.pass4", "doc": "## Name\nprobe::stap.pass4 — \n     Starting stap pass4 (compile C code into kernel module)\n## Synopsis\n```\nstap.pass4 \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass4 fires just after the call to gettimeofday, just before the\n   call to compile_pass.\n" },
    { "name": "stap.pass4.end", "doc": "## Name\nprobe::stap.pass4.end — \n     Finished stap pass4 (compile C code into kernel module)\n## Synopsis\n```\nstap.pass4.end \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass4.end fires just before the jump to cleanup if s.last_pass = 4\n" },
    { "name": "stap.pass3", "doc": "## Name\nprobe::stap.pass3 — \n     Starting stap pass3 (translation to C)\n## Synopsis\n```\nstap.pass3 \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass3 fires just after the call to gettimeofday, just before the\n   call to translate_pass.\n" },
    { "name": "stap.pass3.end", "doc": "## Name\nprobe::stap.pass3.end — \n     Finished stap pass3 (translation to C)\n## Synopsis\n```\nstap.pass3.end \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass3.end fires just before the jump to cleanup if s.last_pass = 3\n" },
    { "name": "stap.pass5", "doc": "## Name\nprobe::stap.pass5 — \n     Starting stap pass5 (running the instrumentation)\n## Synopsis\n```\nstap.pass5 \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass5 fires just after the call to gettimeofday, just before the\n   call to run_pass.\n" },
    { "name": "stap.pass5.end", "doc": "## Name\nprobe::stap.pass5.end — \n     Finished stap pass5 (running the instrumentation)\n## Synopsis\n```\nstap.pass5.end \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass5.end fires just before the cleanup label\n" },
    { "name": "stap.pass6", "doc": "## Name\nprobe::stap.pass6 — \n     Starting stap pass6 (cleanup)\n## Synopsis\n```\nstap.pass6 \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass6 fires just after the cleanup label, essentially the same spot\n   as pass5.end\n" },
    { "name": "stap.pass6.end", "doc": "## Name\nprobe::stap.pass6.end — \n     Finished stap pass6 (cleanup)\n## Synopsis\n```\nstap.pass6.end \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass6.end fires just before main's return.\n" },
    { "name": "stapio.receive_control_message", "doc": "## Name\nprobe::stapio.receive_control_message — \n     Received a control message\n## Synopsis\n```\nstapio.receive_control_message \n```\n## Values\nlen\n     the length (in bytes) of the data blob\n    data\n     a ptr to a binary blob of data sent as the control message\n    type\n     type of message being send; defined in runtime/transport/transport_msgs.h\n## Description\nFires just after a message was receieved and before it's processed.\n" },
    { "name": "staprun.insert_module", "doc": "## Name\nprobe::staprun.insert_module — \n     Inserting SystemTap instrumentation module\n## Synopsis\n```\nstaprun.insert_module \n```\n## Values\npath\n     the full path to the .ko kernel module about to be inserted\n## Description\nFires just before the call to insert the module.\n" },
    { "name": "staprun.remove_module", "doc": "## Name\nprobe::staprun.remove_module — \n     Removing SystemTap instrumentation module\n## Synopsis\n```\nstaprun.remove_module \n```\n## Values\nname\n     the stap module name to be removed (without the .ko extension)\n## Description\nFires just before the call to remove the module.\n" },
    { "name": "staprun.send_control_message", "doc": "## Name\nprobe::staprun.send_control_message — \n     Sending a control message\n## Synopsis\n```\nstaprun.send_control_message \n```\n## Values\ndata\n     a ptr to a binary blob of data sent as the control message\n    len\n     the length (in bytes) of the data blob\n    type\n     type of message being send; defined in runtime/transport/transport_msgs.h\n## Description\nFires at the beginning of the send_request function.\n" },
    { "name": "nfs.aop.readpage", "doc": "## Name\nprobe::nfs.aop.readpage — \n     NFS client synchronously reading a page\n## Synopsis\n```\nnfs.aop.readpage \n```\n## Values\nfile\n     file argument\n    i_size\n     file length in bytes\n    size\n     number of pages to be read in this execution \n    __page\n     the address of page\n    sb_flag\n     super block flags\n    ino\n     inode number\n    page_index\n     offset within mapping, can used a page identifier\n     and position identifier in the page frame\n    i_flag\n     file flags\n    rsize\n     read size  (in bytes)\n    dev\n     device identifier\n## Description\nRead the page over, only fires when a previous async\n   read operation failed\n" },
    { "name": "nfs.aop.release_page", "doc": "## Name\nprobe::nfs.aop.release_page — \n     NFS client releasing page\n## Synopsis\n```\nnfs.aop.release_page \n```\n## Values\nsize\n     release pages\n    dev\n     device identifier\n    page_index\n     offset within mapping, can used a page identifier\n     and position identifier in the page frame\n    ino\n     inode number\n    __page\n     the address of page\n## Description\nFires when do a release operation on NFS.\n" },
    { "name": "stap.system.spawn", "doc": "## Name\nprobe::stap.system.spawn — \n     stap spawned new process\n## Synopsis\n```\nstap.system.spawn \n```\n## Values\npid\n     the pid of the spawned process\n    ret\n     the return value from posix_spawn\n## Description\nFires just after the call to posix_spawn.\n" },
    { "name": "stap.system", "doc": "## Name\nprobe::stap.system — \n     Starting a command from stap\n## Synopsis\n```\nstap.system \n```\n## Values\ncommand\n     the command string to be run by posix_spawn (as sh -c <str>)\n## Description\nFires at the entry of the stap_system command.\n" },
    { "name": "nfs.fop.flush", "doc": "## Name\nprobe::nfs.fop.flush — \n     NFS client flush file operation\n## Synopsis\n```\nnfs.fop.flush \n```\n## Values\ndev\n     device identifier\n    ndirty\n     number of dirty page\n    mode\n     file mode\n    ino\n     inode number\n" },
    { "name": "nfs.fop.llseek", "doc": "## Name\nprobe::nfs.fop.llseek — \n  NFS client llseek operation\n## Synopsis\n```\nnfs.fop.llseek \n```\n## Values\noffset\n     the offset of the file will be repositioned\n    dev\n     device identifier\n    ino\n     inode number\n    whence_str\n     symbolic string representation of the position to seek from\n    whence\n     the position to seek from\n" },
    { "name": "nfs.aop.write_begin", "doc": "## Name\nprobe::nfs.aop.write_begin — \n     NFS client begin to write data\n## Synopsis\n```\nnfs.aop.write_begin \n```\n## Values\nsize\n     write bytes\n    offset\n     start address of this write operation \n    page_index\n     offset within mapping, can used a page identifier\n     and position identifier in the page frame\n    ino\n     inode number \n    __page\n     the address of page\n    dev\n     device identifier\n    to\n     end address of this write operation\n## Description\nOccurs when write operation occurs on nfs. It prepare a page for writing,\n   look for a request corresponding to the page. If there\n   is one, and it belongs to another file, it flush it out\n   before it tries to copy anything into the page. \n   Also do the same if it finds a request from an existing\n   dropped page\n" },
    { "name": "nfs.aop.readpages", "doc": "## Name\nprobe::nfs.aop.readpages — \n     NFS client reading multiple pages\n## Synopsis\n```\nnfs.aop.readpages \n```\n## Values\nsize\n     number of pages attempted to read in this execution\n    rpages\n     read size (in pages)\n    file\n     filp argument\n    rsize\n     read size (in bytes)\n    dev\n     device identifier\n    ino\n     inode number   \n    nr_pages\n     number of pages attempted to read in this execution\n## Description\nFires when in readahead way, read several pages once\n" },
    { "name": "nfs.fop.mmap", "doc": "## Name\nprobe::nfs.fop.mmap — \n     NFS client mmap operation\n## Synopsis\n```\nnfs.fop.mmap \n```\n## Values\nparent_name\n     parent dir name\n    cache_time\n     when we started read-caching this inode\n    vm_end\n     the first byte after end address within vm_mm\n    attrtimeo\n     how long the cached information is assumed to be valid.\n     We need to revalidate the cached attrs for this inode \n     if jiffies - read_cache_jiffies > attrtimeo.\n    vm_start\n     start address within vm_mm \n    ino\n     inode number        \n    vm_flag\n     vm flags\n    buf\n     the address of buf in user space\n    dev\n     device identifier\n    cache_valid\n     cache related bit mask flag\n    file_name\n     file name\n" },
    { "name": "nfs.fop.open", "doc": "## Name\nprobe::nfs.fop.open — \n     NFS client file open operation\n## Synopsis\n```\nnfs.fop.open \n```\n## Values\ni_size\n     file length in bytes \n    flag\n     file flag\n    dev\n     device identifier\n    file_name\n     file name\n    ino\n     inode number\n" },
    { "name": "nfs.fop.read", "doc": "## Name\nprobe::nfs.fop.read — \n     NFS client read operation\n## Synopsis\n```\nnfs.fop.read \n```\n## Values\ndevname\n     block device name\n## Description\nSystemTap uses the vfs.do_sync_read probe to implement this probe\n   and as a result will get operations other than the NFS client read\n   operations.\n" },
    { "name": "nfs.fop.lock", "doc": "## Name\nprobe::nfs.fop.lock — \n     NFS client file lock operation\n## Synopsis\n```\nnfs.fop.lock \n```\n## Values\nfl_flag\n     lock flags\n    fl_start\n     starting offset of locked region\n    fl_end\n     ending offset of locked region\n    fl_type\n     lock type\n    dev\n     device identifier\n    ino\n     inode number\n    cmd\n     cmd arguments\n    i_mode\n     file type and access rights\n" },
    { "name": "nfs.fop.sendfile", "doc": "## Name\nprobe::nfs.fop.sendfile — \n     NFS client send file operation\n## Synopsis\n```\nnfs.fop.sendfile \n```\n## Values\nattrtimeo\n     how long the cached information is assumed to be valid.\n     We need to revalidate the cached attrs for this inode\n     if jiffies - read_cache_jiffies > attrtimeo.\n    cache_time\n     when we started read-caching this inode\n    dev\n     device identifier\n    cache_valid\n     cache related bit mask flag\n    ino\n     inode number\n    count\n     read bytes\n    ppos\n     current position of file\n" },
    { "name": "stap.pass1.end", "doc": "## Name\nprobe::stap.pass1.end — \n     Finished stap pass1 (parsing scripts)\n## Synopsis\n```\nstap.pass1.end \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass1.end fires just before the jump to cleanup if s.last_pass = 1.\n" },
    { "name": "stap.pass0", "doc": "## Name\nprobe::stap.pass0 — \n  Starting stap pass0 (parsing command line arguments)\n## Synopsis\n```\nstap.pass0 \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass0 fires after command line arguments have been parsed.\n" },
    { "name": "stap.pass1b", "doc": "## Name\nprobe::stap.pass1b — \n     Starting stap pass1 (parsing library scripts)\n## Synopsis\n```\nstap.pass1b \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass1b fires just before the library scripts are parsed.\n" },
    { "name": "stap.cache_get", "doc": "## Name\nprobe::stap.cache_get — \n     Found item in stap cache\n## Synopsis\n```\nstap.cache_get \n```\n## Values\nmodule_path\n     the path of the .ko kernel module file\n    source_path\n     the path of the .c source file\n## Description\nFires just before the return of get_from_cache, when the cache grab\n   is successful.\n" },
    { "name": "nfs.fop.write_iter", "doc": "## Name\nprobe::nfs.fop.write_iter — \n     NFS client write_iter file operation\n## Synopsis\n```\nnfs.fop.write_iter \n```\n## Values\npos\n     offset of the file \n    parent_name\n     parent dir name\n    ino\n     inode number        \n    count\n     read bytes\n    dev\n     device identifier\n    file_name\n     file name\n" },
    { "name": "nfs.aop.writepage", "doc": "## Name\nprobe::nfs.aop.writepage — \n     NFS client writing a mapped page to the NFS server\n## Synopsis\n```\nnfs.aop.writepage \n```\n## Values\nwsize\n     write size\n    i_flag\n     file flags\n    for_reclaim\n     a flag of writeback_control,\n     indicates if it's invoked from the page allocator\n    size\n     number of pages to be written in this execution\n    i_size\n     file length in bytes\n    dev\n     device identifier\n    __page\n     the address of page\n    sb_flag\n     super block flags\n    page_index\n     offset within mapping,\n     can used a page identifier and position identifier in the page frame\n    ino\n     inode number  \n    for_kupdate\n     a flag of writeback_control,\n     indicates if it's a kupdate writeback\n    i_state\n     inode state flags\n## Description\nThe priority of wb is decided by the flags\n   for_reclaim and for_kupdate.\n" },
    { "name": "nfs.aop.write_end", "doc": "## Name\nprobe::nfs.aop.write_end — \n     NFS client complete writing data\n## Synopsis\n```\nnfs.aop.write_end \n```\n## Values\ni_size\n     file length in bytes\n    size\n     write bytes\n    offset\n     start address of this write operation\n    i_flag\n     file flags\n    to\n     end address of this write operation\n    page_index\n     offset within mapping, can used a page identifier and position identifier in the page frame\n    ino\n     inode number\n    __page\n     the address of page\n    sb_flag\n     super block flags\n    dev\n     device identifier\n## Description\nFires when do a write operation on nfs,\n   often after prepare_write\nUpdate and possibly write a cached page of an NFS file.\n" },
    { "name": "nfs.proc.commit_setup", "doc": "## Name\nprobe::nfs.proc.commit_setup — \n     NFS client setting up a commit RPC task\n## Synopsis\n```\nnfs.proc.commit_setup \n```\n## Values\nbitmask1\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    size\n     bytes in this commit\n    count\n     bytes in this commit\n    offset\n     the file offset\n    bitmask0\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    server_ip\n     IP address of server\n    prot\n     transfer protocol\n    version\n     NFS version\n## Description\nThe commit_setup function is used to setup a commit RPC task.\n   Is is not doing the actual commit operation.\n   It does not exist in NFSv2.\n" },
    { "name": "nfs.aop.set_page_dirty", "doc": "## Name\nprobe::nfs.aop.set_page_dirty — \n     NFS client marking page as dirty\n## Synopsis\n```\nnfs.aop.set_page_dirty \n```\n## Values\n__page\n     the address of page\n    page_flag\n     page flags\n## Description\nThis probe attaches to the generic __set_page_dirty_nobuffers function.\n   Thus, this probe is going to fire on many other file systems in\n   addition to the NFS client.\n" },
    { "name": "nfs.proc.create", "doc": "## Name\nprobe::nfs.proc.create — \n     NFS client creating file on server\n## Synopsis\n```\nnfs.proc.create \n```\n## Values\nfilelen\n     length of file name\n    fh\n     file handle of parent dir\n    flag\n     indicates create mode (only for NFSv3 and NFSv4)\n    filename\n     file name\n    server_ip\n     IP address of server\n    version\n     NFS version (the function is used for all NFS version)\n    prot\n     transfer protocol\n" },
    { "name": "nfs.proc.lookup", "doc": "## Name\nprobe::nfs.proc.lookup — \n  NFS client opens/searches a file on server\n## Synopsis\n```\nnfs.proc.lookup \n```\n## Values\nbitmask1\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    filename\n     the name of file which client opens/searches on server\n    server_ip\n     IP address of server\n    bitmask0\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    name_len\n     the length of file name\n    prot\n     transfer protocol\n    version\n     NFS version\n" },
    { "name": "nfs.fop.release", "doc": "## Name\nprobe::nfs.fop.release — \n     NFS client release page operation\n## Synopsis\n```\nnfs.fop.release \n```\n## Values\nino\n     inode number\n    mode\n     file mode\n    dev\n     device identifier\n" },
    { "name": "nfs.fop.aio_write", "doc": "## Name\nprobe::nfs.fop.aio_write — \n     NFS client aio_write file operation\n## Synopsis\n```\nnfs.fop.aio_write \n```\n## Values\npos\n     offset of the file \n    parent_name\n     parent dir name\n    count\n     read bytes\n    ino\n     inode number        \n    dev\n     device identifier\n    buf\n     the address of buf in user space\n    file_name\n     file name\n" },
    { "name": "nfs.proc.release", "doc": "## Name\nprobe::nfs.proc.release — \n     NFS client releases file read/write context information\n## Synopsis\n```\nnfs.proc.release \n```\n## Values\nmode\n     file mode\n    flag\n     file flag\n    filename\n     file name\n    server_ip\n     IP address of server\n    version\n     NFS version (the function is used for all NFS version)\n    prot\n     transfer protocol\n## Description\nRelease file read/write context information\n" },
    { "name": "nfs.proc.read_setup", "doc": "## Name\nprobe::nfs.proc.read_setup — \n     NFS client setting up a read RPC task\n## Synopsis\n```\nnfs.proc.read_setup \n```\n## Values\nsize\n     read bytes in this execution\n    count\n     read bytes in this execution\n    offset\n     the file offset \n    server_ip\n     IP address of server\n    prot\n     transfer protocol\n    version\n     NFS version\n## Description\nThe read_setup function is used to setup a read RPC task.\n   It is not doing the actual read operation.\n" },
    { "name": "nfs.proc.rename", "doc": "## Name\nprobe::nfs.proc.rename — \n     NFS client renames a file on server\n## Synopsis\n```\nnfs.proc.rename \n```\n## Values\nnew_fh\n     file handle of new parent dir\n    new_filelen\n     length of new file name\n    old_fh\n     file handle of old parent dir\n    old_filelen\n     length of old file name\n    version\n     NFS version (the function is used for all NFS version)\n    old_name\n     old file name\n    prot\n     transfer protocol\n    new_name\n     new file name\n    server_ip\n     IP address of server\n" },
    { "name": "nfs.proc.rename_done", "doc": "## Name\nprobe::nfs.proc.rename_done — \n     NFS client response to a rename RPC task\n## Synopsis\n```\nnfs.proc.rename_done \n```\n## Values\nnew_fh\n     file handle of new parent dir\n    status\n     result of last operation\n    old_fh\n     file handle of old parent dir\n    timestamp\n     V4 timestamp, which is used for lease renewal\n    version\n     NFS version\n    prot\n     transfer protocol\n    server_ip\n     IP address of server\n## Description\nFires when a reply to a rename RPC task is received or some rename\n   error occurs (timeout or socket shutdown).\n" },
    { "name": "nfs.proc.rename_setup", "doc": "## Name\nprobe::nfs.proc.rename_setup — \n     NFS client setting up a rename RPC task\n## Synopsis\n```\nnfs.proc.rename_setup \n```\n## Values\nfh\n     file handle of parent dir\n    prot\n     transfer protocol\n    version\n     NFS version\n    server_ip\n     IP address of server\n## Description\nThe rename_setup function is used to setup a rename RPC task.\n   Is is not doing the actual rename operation.\n" },
    { "name": "nfs.proc.write_done", "doc": "## Name\nprobe::nfs.proc.write_done — \n     NFS client response to a write RPC task\n## Synopsis\n```\nnfs.proc.write_done \n```\n## Values\nprot\n     transfer protocol\n    version\n     NFS version\n    valid\n     fattr->valid, indicates which fields are valid \n    server_ip\n     IP address of server\n    status\n     result of last operation\n    count\n     number of bytes written\n    timestamp\n     V4 timestamp, which is used for lease renewal\n## Description\nFires when a reply to a write RPC task is received or some write error occurs\n   (timeout or socket shutdown).\n" },
    { "name": "signal.force_segv", "doc": "## Name\nprobe::signal.force_segv — \n     Forcing send of SIGSEGV\n## Synopsis\n```\nsignal.force_segv \n```\n## Values\nsig\n     The number of the signal\n    name\n     Name of the probe point\n    sig_pid\n     The PID of the process receiving the signal\n    sig_name\n     A string representation of the signal\n    pid_name\n     Name of the process receiving the signal\n" },
    { "name": "nfsd.close", "doc": "## Name\nprobe::nfsd.close — \n     NFS server closing a file for client\n## Synopsis\n```\nnfsd.close \n```\n## Values\nfilename\n     file name\n## Description\nThis probe point does not exist in kernels starting with 4.2.\n" },
    { "name": "nfsd.commit", "doc": "## Name\nprobe::nfsd.commit — \n     NFS server committing all pending writes to stable storage\n## Synopsis\n```\nnfsd.commit \n```\n## Values\noffset\n     the offset of file\n    count\n     read bytes\n    fh\n     file handle (the first part is the length of the file handle)\n    size\n     read bytes\n    flag\n     indicates whether this execution is a sync operation\n    client_ip\n     the ip address of client\n" },
    { "name": "nfs.proc.read_done", "doc": "## Name\nprobe::nfs.proc.read_done — \n     NFS client response to a read RPC task\n## Synopsis\n```\nnfs.proc.read_done \n```\n## Values\nprot\n     transfer protocol\n    version\n     NFS version\n    server_ip\n     IP address of server\n    status\n     result of last operation\n    count\n     number of bytes read\n    timestamp\n     V4 timestamp, which is used for lease renewal\n## Description\nFires when a reply to a read RPC task is received or some read error occurs\n   (timeout or socket shutdown).\n" },
    { "name": "nfsd.create", "doc": "## Name\nprobe::nfsd.create — \n     NFS server creating a file(regular,dir,device,fifo) for client\n## Synopsis\n```\nnfsd.create \n```\n## Values\nclient_ip\n     the ip address of client\n    type\n     file type(regular,dir,device,fifo ...)\n    iap_valid\n     Attribute flags\n    filename\n     file name \n    iap_mode\n     file access mode\n    filelen\n     the length of file name\n    fh\n     file handle (the first part is the length of the file handle)\n## Description\nSometimes nfsd will call nfsd_create_v3 instead of this this probe point.\n" },
    { "name": "nfs.aop.writepages", "doc": "## Name\nprobe::nfs.aop.writepages — \n     NFS client writing several dirty pages to the NFS server\n## Synopsis\n```\nnfs.aop.writepages \n```\n## Values\nfor_reclaim\n     a flag of writeback_control,\n     indicates if it's invoked from the page allocator\n    wpages\n     write size (in pages)\n    size\n     number of pages attempted to be written in this execution\n    wsize\n     write size\n    for_kupdate\n     a flag of writeback_control,\n     indicates if it's a kupdate writeback\n    nr_to_write\n     number of pages attempted to be written in this execution\n    ino\n     inode number\n    dev\n     device identifier\n## Description\nThe priority of wb is decided by the flags\n   for_reclaim and for_kupdate.\n" },
    { "name": "nfsd.createv3", "doc": "## Name\nprobe::nfsd.createv3 — \n     NFS server creating a regular file or set file attributes for client\n## Synopsis\n```\nnfsd.createv3 \n```\n## Values\nfilename\n     file name \n    iap_valid\n     Attribute flags\n    verifier\n     file attributes (atime,mtime,mode). It's used to reset file attributes for CREATE_EXCLUSIVE\n    client_ip\n     the ip address of client\n    fh\n     file handle (the first part is the length of the file handle)\n    truncp\n     trunp arguments, indicates if the file shouldbe truncate\n    filelen\n     the length of file name\n    createmode\n     create mode .The possible values could be: NFS3_CREATE_EXCLUSIVE, NFS3_CREATE_UNCHECKED, or NFS3_CREATE_GUARDED\n    iap_mode\n     file access mode\n## Description\nThis probepoints is only called by nfsd3_proc_create and\n   nfsd4_open when op_claim_type is NFS4_OPEN_CLAIM_NULL.\n" },
    { "name": "nfs.fop.read_iter", "doc": "## Name\nprobe::nfs.fop.read_iter — \n     NFS client read_iter file operation\n## Synopsis\n```\nnfs.fop.read_iter \n```\n## Values\ncache_time\n     when we started read-caching this inode\n    attrtimeo\n     how long the cached information is assumed to be valid.\n     We need to revalidate the cached attrs for this inode\n     if jiffies - read_cache_jiffies > attrtimeo.\n    pos\n     current position of file   \n    parent_name\n     parent dir name\n    count\n     read bytes\n    ino\n     inode number        \n    dev\n     device identifier\n    file_name\n     file name\n    cache_valid\n     cache related bit mask flag\n" },
    { "name": "nfs.proc.handle_exception", "doc": "## Name\nprobe::nfs.proc.handle_exception — \n     NFS client handling an NFSv4 exception\n## Synopsis\n```\nnfs.proc.handle_exception \n```\n## Values\nerrorcode\n     indicates the type of error\n## Description\nThis is the error handling routine for processes for NFSv4.\n" },
    { "name": "nfsd.lookup", "doc": "## Name\nprobe::nfsd.lookup — \n     NFS server opening or searching file for a file for client\n## Synopsis\n```\nnfsd.lookup \n```\n## Values\nclient_ip\n     the ip address of client\n    filename\n     file name \n    filelen\n     the length of file name\n    fh\n     file handle of parent dir(the first part is the length of the file handle)\n" },
    { "name": "nfs.fop.fsync", "doc": "## Name\nprobe::nfs.fop.fsync — \n     NFS client fsync operation\n## Synopsis\n```\nnfs.fop.fsync \n```\n## Values\nino\n     inode number\n    ndirty\n     number of dirty pages\n    dev\n     device identifier\n" },
    { "name": "nfs.proc.write", "doc": "## Name\nprobe::nfs.proc.write — \n     NFS client synchronously writes file to server\n## Synopsis\n```\nnfs.proc.write \n```\n## Values\nflags\n     used to set task->tk_flags in rpc_init_task function\n    offset\n     the file offset\n    size\n     read bytes in this execution\n    bitmask1\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    version\n     NFS version\n    prot\n     transfer protocol\n    bitmask0\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    server_ip\n     IP address of server\n## Description\nAll the nfs.proc.write kernel functions were removed in kernel commit\n   200baa in December 2006, so these probes do not exist on Linux\n   2.6.21 and newer kernels.\n" },
    { "name": "nfsd.open", "doc": "## Name\nprobe::nfsd.open — \n     NFS server opening a file for client\n## Synopsis\n```\nnfsd.open \n```\n## Values\nfh\n     file handle (the first part is the length of the file handle)\n    client_ip\n     the ip address of client\n    type\n     type of file (regular file or dir)\n    access\n     indicates the type of open (read/write/commit/readdir...)\n" },
    { "name": "nfsd.dispatch", "doc": "## Name\nprobe::nfsd.dispatch — \n  NFS server receives an operation from client\n## Synopsis\n```\nnfsd.dispatch \n```\n## Values\nprog\n     program number\n    xid\n     transmission id\n    proc\n     procedure number\n    version\n     nfs version\n    proto\n     transfer protocol\n    client_ip\n     the ip address of client\n" },
    { "name": "nfsd.proc.commit", "doc": "## Name\nprobe::nfsd.proc.commit — \n     NFS server performing a commit operation for client\n## Synopsis\n```\nnfsd.proc.commit \n```\n## Values\nversion\n     nfs version\n    client_ip\n     the ip address of client\n    proto\n     transfer protocol\n    count\n     read bytes\n    fh\n     file handle (the first part is the length of the file handle)\n    size\n     read bytes\n    uid\n     requester's user id\n    offset\n     the offset of file \n    gid\n     requester's group id\n" },
    { "name": "nfsd.proc.create", "doc": "## Name\nprobe::nfsd.proc.create — \n     NFS server creating a file for client\n## Synopsis\n```\nnfsd.proc.create \n```\n## Values\nfilelen\n     length of file name\n    gid\n     requester's group id\n    proto\n     transfer protocol\n    uid\n     requester's user id\n    fh\n     file handle (the first part is the length of the file handle)\n    client_ip\n     the ip address of client\n    version\n     nfs version\n    filename\n     file name\n" },
    { "name": "nfsd.proc.lookup", "doc": "## Name\nprobe::nfsd.proc.lookup — \n     NFS server opening or searching for a file for client\n## Synopsis\n```\nnfsd.proc.lookup \n```\n## Values\nproto\n     transfer protocol\n    fh\n     file handle of parent dir (the first part is the length of the file handle)\n    filename\n     file name \n    uid\n     requester's user id\n    filelen\n     the length of file name\n    version\n     nfs version\n    client_ip\n     the ip address of client\n    gid\n     requester's group id\n" },
    { "name": "nfsd.read", "doc": "## Name\nprobe::nfsd.read — \n     NFS server reading data from a file for client\n## Synopsis\n```\nnfsd.read \n```\n## Values\nvec\n     struct kvec, includes buf address in kernel address and length of each buffer\n    client_ip\n     the ip address of client\n    vlen\n     read blocks \n    file\n     argument file, indicates if the file has been opened.\n    offset\n     the offset of file \n    fh\n     file handle (the first part is the length of the file handle)\n    count\n     read bytes\n    size\n     read bytes\n" },
    { "name": "nfsd.proc.write", "doc": "## Name\nprobe::nfsd.proc.write — \n     NFS server writing data to file for client\n## Synopsis\n```\nnfsd.proc.write \n```\n## Values\nclient_ip\n     the ip address of client\n    version\n     nfs version\n    vec\n     struct kvec, includes buf address in kernel address and length of each buffer\n    stable\n     argp->stable\n    vlen\n     read blocks \n    gid\n     requester's group id\n    proto\n     transfer protocol\n    offset\n     the offset of file \n    size\n     read bytes\n    uid\n     requester's user id\n    fh\n     file handle (the first part is the length of the file handle)\n    count\n     read bytes\n" },
    { "name": "nfsd.proc.remove", "doc": "## Name\nprobe::nfsd.proc.remove — \n     NFS server removing a file for client\n## Synopsis\n```\nnfsd.proc.remove \n```\n## Values\nfilename\n     file name\n    version\n     nfs version\n    client_ip\n     the ip address of client\n    proto\n     transfer protocol\n    fh\n     file handle (the first part is the length of the file handle)\n    uid\n     requester's user id\n    filelen\n     length of file name\n    gid\n     requester's group id\n" },
    { "name": "socket.create.return", "doc": "## Name\nprobe::socket.create.return — \n     Return from Creation of a socket\n## Synopsis\n```\nsocket.create.return \n```\n## Values\nname\n     Name of this probe\n    success\n     Was socket creation successful? (1 = yes, 0 = no)\n    type\n     Socket type value\n    protocol\n     Protocol value\n    family\n     Protocol family value\n    err\n     Error code if success == 0\n    requester\n     Requested by user process or the kernel (1 = kernel, 0 = user)\n## Context\nThe requester (user process or kernel)\n## Description\nFires at the conclusion of creating a socket.\n" },
    { "name": "nfsd.unlink", "doc": "## Name\nprobe::nfsd.unlink — \n     NFS server removing a file or a directory for client\n## Synopsis\n```\nnfsd.unlink \n```\n## Values\nclient_ip\n     the ip address of client\n    type\n     file type (file or dir)\n    filename\n     file name \n    filelen\n     the length of file name\n    fh\n     file handle (the first part is the length of the file handle)\n" },
    { "name": "nfsd.write", "doc": "## Name\nprobe::nfsd.write — \n     NFS server writing data to a file for client\n## Synopsis\n```\nnfsd.write \n```\n## Values\nfile\n     argument file, indicates if the file has been opened.\n    offset\n     the offset of file \n    count\n     read bytes\n    fh\n     file handle (the first part is the length of the file handle)\n    size\n     read bytes\n    vec\n     struct kvec, includes buf address in kernel address and length of each buffer\n    client_ip\n     the ip address of client\n    vlen\n     read blocks\n" },
    { "name": "nfs.fop.check_flags", "doc": "## Name\nprobe::nfs.fop.check_flags — \n     NFS client checking flag operation\n## Synopsis\n```\nnfs.fop.check_flags \n```\n## Values\nflag\n     file flag\n" },
    { "name": "nfs.proc.commit_done", "doc": "## Name\nprobe::nfs.proc.commit_done — \n     NFS client response to a commit RPC task\n## Synopsis\n```\nnfs.proc.commit_done \n```\n## Values\nvalid\n     fattr->valid, indicates which fields are valid \n    server_ip\n     IP address of server\n    version\n     NFS version\n    prot\n     transfer protocol\n    timestamp\n     V4 timestamp, which is used for lease renewal\n    status\n     result of last operation\n    count\n     number of bytes committed\n## Description\nFires when a reply to a commit RPC task is received\n   or some commit operation error occur (timeout or socket shutdown).\n" },
    { "name": "nfs.fop.aio_read", "doc": "## Name\nprobe::nfs.fop.aio_read — \n     NFS client aio_read file operation\n## Synopsis\n```\nnfs.fop.aio_read \n```\n## Values\ncount\n     read bytes\n    ino\n     inode number        \n    dev\n     device identifier\n    buf\n     the address of buf in user space\n    cache_valid\n     cache related bit mask flag\n    file_name\n     file name\n    pos\n     current position of file   \n    parent_name\n     parent dir name\n    cache_time\n     when we started read-caching this inode\n    attrtimeo\n     how long the cached information is assumed to be valid.\n     We need to revalidate the cached attrs for this inode\n     if jiffies - read_cache_jiffies > attrtimeo.\n" },
    { "name": "nfs.fop.write", "doc": "## Name\nprobe::nfs.fop.write — \n     NFS client write operation\n## Synopsis\n```\nnfs.fop.write \n```\n## Values\ndevname\n     block device name\n## Description\nSystemTap uses the vfs.do_sync_write probe to implement this probe\n   and as a result will get operations other than the NFS client write\n   operations.\n" },
    { "name": "json_data", "doc": "## Name\nprobe::json_data — \n     Fires whenever JSON data is wanted by a reader.\n## Synopsis\n```\njson_data \n```\n## Values\nNone\n## Context\nThis probe fires when the JSON data is about to be read. This\n   probe must gather up data and then call the following macros to\n   output the data in JSON format. First, @json_output_data_start\n   must be called. That call is followed by one or more of the\n   following (one call for each data item):\n   @json_output_string_value, @json_output_numeric_value,\n   @json_output_array_string_value, and\n   @json_output_array_numeric_value. Finally @json_output_data_end\n   must be called.\n" },
    { "name": "syscall_any.return", "doc": "## Name\nprobe::syscall_any.return — \n     Record exit from a syscall\n## Synopsis\n```\nsyscall_any.return \n```\n## Values\nname\n     name of the syscall\n    syscall_nr\n     number of the syscall\n    retval\n     return value of the syscall\n## Context\nThe process performing the syscall\n## Description\nThe syscall_any.return probe point is designed to be a low overhead\n   that monitors all the syscalls returns via a kernel tracepoint.\n   Because of the breadth of syscalls it monitors it provides\n   no information about the syscall arguments, argstr string\n   representation of those arguments, or a string interpretation\n   of the return value (retval).\nThis requires kernel 3.5+ and newer which have the\n   kernel.trace(“sys_exit”) probe point.\n" },
    { "name": "nfsd.proc.rename", "doc": "## Name\nprobe::nfsd.proc.rename — \n     NFS Server renaming a file for client\n## Synopsis\n```\nnfsd.proc.rename \n```\n## Values\ngid\n     requester's group id\n    fh\n     file handler of old path\n    uid\n     requester's user id\n    tname\n     new file name\n    tfh\n     file handler of new path\n    tlen\n     length of new file name\n    client_ip\n     the ip address of client\n    flen\n     length of old file name \n    filename\n     old file name\n" },
    { "name": "nfsd.rename", "doc": "## Name\nprobe::nfsd.rename — \n     NFS server renaming a file for client\n## Synopsis\n```\nnfsd.rename \n```\n## Values\nfilename\n     old file name \n    tlen\n     length of new file name\n    client_ip\n     the ip address of client\n    flen\n     length of old file name \n    fh\n     file handler of old path\n    tfh\n     file handler of new path\n    tname\n     new file name\n" },
    { "name": "syscall_any", "doc": "## Name\nprobe::syscall_any — \n  Record entry into a syscall\n## Synopsis\n```\nsyscall_any \n```\n## Values\nname\n     name of the syscall\n    syscall_nr\n     number of the syscall\n## Context\nThe process performing the syscall\n## Description\nThe syscall_any probe point is designed to be a low overhead\n   that monitors all the syscalls entered via a kernel tracepoint.\n   Because of the breadth of syscalls it monitors it provides\n   no information about the syscall arguments or argstr string\n   representation of those arguments.\nThis requires kernel 3.5+ and newer which have the\n   kernel.trace(“sys_enter”) probe point.\n" },
    { "name": "nfs.proc.commit", "doc": "## Name\nprobe::nfs.proc.commit — \n     NFS client committing data on server\n## Synopsis\n```\nnfs.proc.commit \n```\n## Values\nbitmask1\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    size\n     read bytes in this execution\n    offset\n     the file offset\n    bitmask0\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    server_ip\n     IP address of server\n    prot\n     transfer protocol\n    version\n     NFS version\n## Description\nAll the nfs.proc.commit kernel functions were removed in kernel\n   commit 200baa in December 2006, so these probes do not exist on Linux\n   2.6.21 and newer kernels.\nFires when client writes the buffered data to disk.\n   The buffered data is asynchronously written by client earlier.\n   The commit function works in sync way.\n   This probe point does not exist in NFSv2.\n" },
    { "name": "nfs.proc.remove", "doc": "## Name\nprobe::nfs.proc.remove — \n     NFS client removes a file on server\n## Synopsis\n```\nnfs.proc.remove \n```\n## Values\nfh\n     file handle of parent dir\n    filelen\n     length of file name\n    prot\n     transfer protocol\n    version\n     NFS version (the function is used for all NFS version)\n    server_ip\n     IP address of server\n    filename\n     file name\n" },
    { "name": "nfs.proc.read", "doc": "## Name\nprobe::nfs.proc.read — \n     NFS client synchronously reads file from server\n## Synopsis\n```\nnfs.proc.read \n```\n## Values\nserver_ip\n     IP address of server\n    prot\n     transfer protocol\n    version\n     NFS version\n    count\n     read bytes in this execution\n    offset\n     the file offset\n    flags\n     used to set task->tk_flags in rpc_init_task function\n## Description\nAll the nfs.proc.read kernel functions were removed in kernel commit\n   8e0969 in December 2006, so these probes do not exist on Linux\n   2.6.21 and newer kernels.\n" },
    { "name": "signal.syskill", "doc": "## Name\nprobe::signal.syskill — \n     Sending kill signal to a process\n## Synopsis\n```\nsignal.syskill \n```\n## Values\ntask\n     A task handle to the signal recipient\n    sig\n     The specific signal sent to the process\n    sig_pid\n     The PID of the process receiving the signal\n    sig_name\n     A string representation of the signal\n    name\n     Name of the probe point\n    pid_name\n     The name of the signal recipient\n" },
    { "name": "stap.pass2", "doc": "## Name\nprobe::stap.pass2 — \n     Starting stap pass2 (elaboration)\n## Synopsis\n```\nstap.pass2 \n```\n## Values\nsession\n     the systemtap_session variable s\n## Description\npass2 fires just after the call to gettimeofday, just before the \n   call to semantic_pass.\n" },
    { "name": "nfsd.proc.read", "doc": "## Name\nprobe::nfsd.proc.read — \n     NFS server reading file for client\n## Synopsis\n```\nnfsd.proc.read \n```\n## Values\nvlen\n     read blocks \n    gid\n     requester's group id\n    vec\n     struct kvec, includes buf address in kernel address and length of each buffer\n    version\n     nfs version\n    client_ip\n     the ip address of client\n    count\n     read bytes\n    fh\n     file handle (the first part is the length of the file handle)\n    uid\n     requester's user id\n    size\n     read bytes\n    offset\n     the offset of file \n    proto\n     transfer protocol\n" },
    { "name": "nfs.proc.open", "doc": "## Name\nprobe::nfs.proc.open — \n     NFS client allocates file read/write context information\n## Synopsis\n```\nnfs.proc.open \n```\n## Values\nflag\n     file flag\n    mode\n     file mode\n    prot\n     transfer protocol\n    version\n     NFS version (the function is used for all NFS version)\n    filename\n     file name\n    server_ip\n     IP address of server\n## Description\nAllocate file read/write context information\n" },
    { "name": "nfs.proc.write_setup", "doc": "## Name\nprobe::nfs.proc.write_setup — \n     NFS client setting up a write RPC task\n## Synopsis\n```\nnfs.proc.write_setup \n```\n## Values\nsize\n     bytes written in this execution\n    bitmask1\n     V4 bitmask representing the set of attributes supported\n     on this filesystem \n    how\n     used to set args.stable. The stable value could be:\n     NFS_UNSTABLE,NFS_DATA_SYNC,NFS_FILE_SYNC\n     (in nfs.proc3.write_setup and nfs.proc4.write_setup)\n    offset\n     the file offset\n    count\n     bytes written in this execution\n    server_ip\n     IP address of server\n    bitmask0\n     V4 bitmask representing the set of attributes supported\n     on this filesystem\n    version\n     NFS version\n    prot\n     transfer protocol\n## Description\nThe write_setup function is used to setup a write RPC task.\n   It is not doing the actual write operation.\n" },
    { "name": "stap.system.return", "doc": "## Name\nprobe::stap.system.return — \n     Finished a command from stap\n## Synopsis\n```\nstap.system.return \n```\n## Values\nret\n     a return code associated with running waitpid on the spawned process; \n     a non-zero value indicates error\n## Description\nFires just before the return of the stap_system function, after waitpid.\n" },
];
